/* cobra_cx24108.c (rosie) */

/*+++ *******************************************************************\
*
*   Copyright and Disclaimer:
*
*       ---------------------------------------------------------------
*       ALL SOFTWARE, APPLICATIONS, DOCUMENTATION, OR MATERIALS        
*       FURNISHED HEREIN IS PROVIDED *AS IS*.  CONEXANT DOES NOT MAKE  
*       ANY WARRANTIES, EITHER EXPRESS OR IMPLIED, AND HEREBY EXPRESSLY
*       DISCLAIMS ANY AND ALL SUCH WARRANTIES TO THE EXTENT PERMITTED  
*       BY LAW, INCLUDING, SPECIFICALLY, ANY IMPLIED WARRANTY ARISING  
*       BY STATUTE OR OTHERWISE IN LAW OR FROM A COURSE OF DEALING OR  
*       USAGE OF TRADE.  CONEXANT DOES NOT MAKE ANY WARRANTIES, EITHER 
*       EXPRESS OR IMPLIED, AND HEREBY EXPRESSLY DISCLAIMS ANY AND ALL 
*       SUCH WARRANTIES WITH RESPECT TO ALL SOFTWARE, APPLICATIONS,    
*       DOCUMENTATION, AND MATERIALS INCLUDING ALL IMPLIED WARRANTIES  
*       OF MERCHANTABILITY, OR OF MERCHANTABLE QUALITY, OR OF FITNESS  
*       FOR ANY PURPOSE, PARTICULAR, SPECIFIC OR OTHERWISE, OR OF      
*       NONINFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OF OTHERS,     
*       RELATING TO THE SOFTWARE, APPLICATIONS, OPERATION,             
*       DOCUMENTATION, DATA OR RESULTS GENERATED BY THE OPERATION OR   
*       USE THEREOF, AND MATERIALS PROVIDED HEREIN.  THE ENTIRE RISK AS
*       TO THE SUBSTANCE, QUALITY AND PERFORMANCE OF SOFTWARE,         
*       APPLICATIONS, AND DOCUMENTATION DESCRIBING SUCH SOFTWARE       
*       REMAINS WITH THE BUYER.                                        
*                                                                      
*       REGARDLESS OF WHETHER ANY REMEDY SET FORTH HEREIN FAILS OF ITS 
*       ESSENTIAL PURPOSE OR OTHERWISE, CONEXANT SHALL NOT BE LIABLE   
*       FOR ANY EXEMPLARY, SPECIAL, PUNITIVE, SPECULATIVE, INDIRECT,   
*       CONSEQUENTIAL OR INCIDENTAL DAMAGES OF ANY KIND (INCLUDING     
*       WITHOUT LIMITATION LOST PROFITS, LOSS OF INCOME, LOSS OF       
*       GOODWILL, OR OTHER TANGIBLE OR INTANGIBLE BUSINESS LOSS)       
*       ARISING OUT OF OR IN CONNECTION WITH, DIRECTLY OR INDIRECTLY,  
*       SOFTWARE, APPLICATIONS, DOCUMENTATION, OR ANY SERVICES OR      
*       MATERIALS PROVIDED HEREUNDER, OR USE OR INABILITY TO USE THE   
*       SOFTWARE, EVEN IF CONEXANT HAS BEEN ADVISED OF THE POSSIBILITY 
*       OF SUCH DAMAGES.                                               
*
*       Copyright (c) 2001 Conexant Systems, Inc.
*       All Rights Reserved.
*       ---------------------------------------------------------------
*
*   Module Revision Id:
*
*       $Header: cobra_cx24108.c, 7, 3/16/04 11:45:12 AM, Billy Jackman$
*
*   Abstract:
*
*       Contains CX24108-specific software.
*
\******************************************************************* ---*/

#include "warnfix.h"
#include <string.h>                    /* ANSI Standard */
#include <time.h>                      /* ANSI Standard */

#include "cobra.h"                     /* Cobra include files, ordered */

/*******************************************************************************************************/
/* _TUNER_CX24108_powerup() */
/*******************************************************************************************************/
BOOL        _TUNER_CX24108_powerup(    /* performs tuner power-up reset */
NIM         *nim)                      /* pointer to nim */
{
  int     err = 0;
  
  unsigned long   ulTemp;
  unsigned long   ulTemp2;

  nim->tuner.cx24108.device_temp_met = False;           /* tuner op. temp not yet met */

  /* set the default settings */
  _TUNER_CX24108_initialize(nim);

  /* wait until chip reaches operating temperature */
  if (nim->tuner.cx24108.device_temp_met == False)
  {
    nim->tuner.cx24108.device_temp_met = True;
    OS_Wait(nim,CX24108_MSTOTEMP);
  }

  /* calculate what lsb of A reg is "worth" at div/2 setting, in Khz */
  if (_TUNER_CX24108_vco_na(nim,(2L),&ulTemp) == False)  err++;
  if (_TUNER_CX24108_vco_na(nim,(1L),&ulTemp2) == False)  err++;
  nim->tuner.cx24108.lsba = ulTemp - ulTemp2;
  nim->lsba_adj = 0;

  if (err == 0)  return(True);
  return(False);

}  /* _TUNER_CX24108_powerup() */


/*******************************************************************************************************/
/* _TUNER_CX24108_initialize() */
/*******************************************************************************************************/
void  _TUNER_CX24108_initialize(       /* initializes the tuner */
NIM   *nim)                            /* pointer to nim */
{
  int  i;

  memset(&nim->tuner.cx24108.tunerparms,CNULL,sizeof(TUNERPARMS));

  /* set default settings */
  nim->tuner.cx24108.CPCPolarity = (int)CPC_POLARITY_NEG;
  nim->tuner.cx24108.vcono = 1;
  nim->tuner.cx24108.vcodiv = VCODIV2;
  nim->tuner.cx24108.R = RDIV_10;               /* not prog'd to tuner -- see RefDivider variable */
  nim->tuner.cx24108.testmode = 0;
  nim->tuner.cx24108.BPPercentage = CX24108_BPDEFAULT;
  nim->vcoedgecnt = 1;

  /* init charge-pump current (CPC) settings */
  nim->tuner.cx24108.tunerparms.CPC[VCO1D2].low = CX24108_CPC_LOW;
  nim->tuner.cx24108.tunerparms.CPC[VCO1D2].mid = CX24108_CPC_MED;
  nim->tuner.cx24108.tunerparms.CPC[VCO1D2].high = CX24108_CPC_HIGH;
  nim->tuner.cx24108.tunerparms.CPC[VCO1D2].LowPercentage = CX24108_CPC_LOWPCT;
  nim->tuner.cx24108.tunerparms.CPC[VCO1D2].HighPercentage = CX24108_CPC_HIPCT;

  nim->tuner.cx24108.tunerparms.CPC[VCO2D2].low = CX24108_CPC_LOW;
  nim->tuner.cx24108.tunerparms.CPC[VCO2D2].mid = CX24108_CPC_MED;
  nim->tuner.cx24108.tunerparms.CPC[VCO2D2].high = CX24108_CPC_HIGH;
  nim->tuner.cx24108.tunerparms.CPC[VCO2D2].LowPercentage = CX24108_CPC_LOWPCT;
  nim->tuner.cx24108.tunerparms.CPC[VCO2D2].HighPercentage = CX24108_CPC_HIPCT;

  nim->tuner.cx24108.tunerparms.CPC[VCO3D2].low = CX24108_CPC_LOW;
  nim->tuner.cx24108.tunerparms.CPC[VCO3D2].mid = CX24108_CPC_MED;
  nim->tuner.cx24108.tunerparms.CPC[VCO3D2].high = CX24108_CPC_HIGH;
  nim->tuner.cx24108.tunerparms.CPC[VCO3D2].LowPercentage = CX24108_CPC_LOWPCT;
  nim->tuner.cx24108.tunerparms.CPC[VCO3D2].HighPercentage = CX24108_CPC_HIPCT;

  nim->tuner.cx24108.tunerparms.CPC[VCO4D2].low = CX24108_CPC_LOW;
  nim->tuner.cx24108.tunerparms.CPC[VCO4D2].mid = CX24108_CPC_MED;
  nim->tuner.cx24108.tunerparms.CPC[VCO4D2].high = CX24108_CPC_HIGH;
  nim->tuner.cx24108.tunerparms.CPC[VCO4D2].LowPercentage = CX24108_CPC_LOWPCT;
  nim->tuner.cx24108.tunerparms.CPC[VCO4D2].HighPercentage = CX24108_CPC_HIPCT;

  nim->tuner.cx24108.tunerparms.CPC[VCO5D2].low = CX24108_CPC_LOW;
  nim->tuner.cx24108.tunerparms.CPC[VCO5D2].mid = CX24108_CPC_MED;
  nim->tuner.cx24108.tunerparms.CPC[VCO5D2].high = CX24108_CPC_HIGH;
  nim->tuner.cx24108.tunerparms.CPC[VCO5D2].LowPercentage = CX24108_CPC_LOWPCT;
  nim->tuner.cx24108.tunerparms.CPC[VCO5D2].HighPercentage = CX24108_CPC_HIPCT;

  nim->tuner.cx24108.tunerparms.CPC[VCO6D2].low = CX24108_CPC_LOW;
  nim->tuner.cx24108.tunerparms.CPC[VCO6D2].mid = CX24108_CPC_MED;
  nim->tuner.cx24108.tunerparms.CPC[VCO6D2].high = CX24108_CPC_HIGH;
  nim->tuner.cx24108.tunerparms.CPC[VCO6D2].LowPercentage = CX24108_CPC_LOWPCT;
  nim->tuner.cx24108.tunerparms.CPC[VCO6D2].HighPercentage = CX24108_CPC_HIPCT;

  nim->tuner.cx24108.tunerparms.CPC[VCO7D2].low = CX24108_CPC_LOW;
  nim->tuner.cx24108.tunerparms.CPC[VCO7D2].mid = CX24108_CPC_MED;
  nim->tuner.cx24108.tunerparms.CPC[VCO7D2].high = CX24108_CPC_HIGH;
  nim->tuner.cx24108.tunerparms.CPC[VCO7D2].LowPercentage = CX24108_CPC_LOWPCT;
  nim->tuner.cx24108.tunerparms.CPC[VCO7D2].HighPercentage = CX24108_CPC_HIPCT;

  nim->tuner.cx24108.tunerparms.CPC[VCO8D2].low = CX24108_CPC_LOW;
  nim->tuner.cx24108.tunerparms.CPC[VCO8D2].mid = CX24108_CPC_MED;
  nim->tuner.cx24108.tunerparms.CPC[VCO8D2].high = CX24108_CPC_HIGH;
  nim->tuner.cx24108.tunerparms.CPC[VCO8D2].LowPercentage = CX24108_CPC_LOWPCT;
  nim->tuner.cx24108.tunerparms.CPC[VCO8D2].HighPercentage = CX24108_CPC_HIPCT;

  /* init tuner slope settings for 1..5, 5..15, 15..45 MSPS */
  /* (recommended default values -- cx24108 data sheet) */
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_1_TO_5].VCASlope = VCAS_52_0DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_1_TO_5].VCAOffset = VCAO_98_5DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_1_TO_5].VGA1Offset = VGA1_30_0DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_1_TO_5].VGA2Offset = VGA2_23DB;

  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_5_TO_15].VCASlope = VCAS_57_0DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_5_TO_15].VCAOffset = VCAO_98_5DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_5_TO_15].VGA1Offset = VGA1_33_0DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_5_TO_15].VGA2Offset = VGA2_14DB;

  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_15_TO_45].VCASlope = VCAS_59_5DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_15_TO_45].VCAOffset = VCAO_98_5DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_15_TO_45].VGA1Offset = VGA1_36_0DB;
  nim->tuner.cx24108.tunerparms.SLP[CX24108_MSPS_15_TO_45].VGA2Offset = VGA2_11DB;

  /* init the tuner vco_edge structure (l/u edges from 6/13 computations) */
  nim->tuner.cx24108.vco_edge[VCO1D2].lower = 2050UL*M/2UL;
  nim->tuner.cx24108.vco_edge[VCO1D2].upperthresh = 2390UL*M/2UL;

  nim->tuner.cx24108.vco_edge[VCO2D2].lower = 2250UL*M/2UL;
  nim->tuner.cx24108.vco_edge[VCO2D2].upperthresh = 2640UL*M/2UL;

  nim->tuner.cx24108.vco_edge[VCO3D2].lower = 2480UL*M/2UL;
  nim->tuner.cx24108.vco_edge[VCO3D2].upperthresh = 2920UL*M/2UL;

  nim->tuner.cx24108.vco_edge[VCO4D2].lower = 2750UL*M/2UL;
  nim->tuner.cx24108.vco_edge[VCO4D2].upperthresh = 3240UL*M/2UL;

  nim->tuner.cx24108.vco_edge[VCO5D2].lower = 3080UL*M/2UL;
  nim->tuner.cx24108.vco_edge[VCO5D2].upperthresh = 3540UL*M/2UL;

  nim->tuner.cx24108.vco_edge[VCO6D2].lower = 3335UL*M/2UL;
  nim->tuner.cx24108.vco_edge[VCO6D2].upperthresh = 3840UL*M/2UL;

  nim->tuner.cx24108.vco_edge[VCO7D2].lower = 3600UL*M/2UL;
  nim->tuner.cx24108.vco_edge[VCO7D2].upperthresh = 4150UL*M/2UL;

  nim->tuner.cx24108.vco_edge[VCO8D2].lower = 3915UL*M/2UL;
  nim->tuner.cx24108.vco_edge[VCO8D2].upperthresh = min((2150UL*M),(4520UL*M/2UL));

  /* init the tuner vco_edge struct for div4 values: vc06/d4, vc07/d4, vc08/d4 */
  nim->tuner.cx24108.vco_edge[VCO6D4].lower = nim->tuner.cx24108.vco_edge[VCO6D2].lower/2UL;
  nim->tuner.cx24108.vco_edge[VCO6D4].upperthresh = nim->tuner.cx24108.vco_edge[VCO6D2].upperthresh/2UL;

  nim->tuner.cx24108.vco_edge[VCO7D4].lower = nim->tuner.cx24108.vco_edge[VCO7D2].lower/2UL;
  nim->tuner.cx24108.vco_edge[VCO7D4].upperthresh = nim->tuner.cx24108.vco_edge[VCO7D2].upperthresh/2UL;

  nim->tuner.cx24108.vco_edge[VCO8D4].lower = max((1019UL*M),(nim->tuner.cx24108.vco_edge[VCO8D2].lower/2UL));
  nim->tuner.cx24108.vco_edge[VCO8D4].upperthresh = max((1075UL*M),(nim->tuner.cx24108.vco_edge[VCO8D2].upperthresh/2UL));

  /* set all frequencies into Hz from khz */
  for (i = (int)VCO1D2 ; i < (int)VCO8D4+1 ; i++)
  {
    nim->tuner.cx24108.vco_edge[i].lower *= M;
    nim->tuner.cx24108.vco_edge[i].upperthresh *= M;

    /* determine the estimated vco lengths, used in vco high-edge calculations (these vco lengths should hold ~ True) */
    nim->tuner.cx24108.vco_len[i] = (nim->tuner.cx24108.vco_edge[i].upperthresh - nim->tuner.cx24108.vco_edge[i].lower);
  }

  /* adjust pre-set vco's if below 2150/2 */
  _TUNER_CX24108_adjust(nim);

  /* init the tuner breakpoint structure */
  for (i = 0 ; i < CX24108_BPCNT ; i++)  
    nim->tuner.cx24108.vco_bp[i].percentage = (int)nim->tuner.cx24108.BPPercentage;

  /* recalculate breakpoints */
  _TUNER_CX24108_calc_bp(nim);

  /* configure the tuner I/O interface with default settings */
  _TUNER_CX24108_defaultsettings(nim);

  return;

}  /* _TUNER_CX24108_initialize() */


/*******************************************************************************************************/
/* _TUNER_CX24108_setgainparms() */
/*******************************************************************************************************/
BOOL        _TUNER_CX24108_setgainparms(  /* copies caller's TUNERPARMS struct into nim */
NIM         *nim,                         /* nim pointer */
TUNERPARMS  *tunerparms)                  /* caller's TUNERPARMS struct that will overwrite nim's struct */
{
  /* copy caller's tunerparms settings into nim */  
  if (tunerparms != NULL)
  {
    memcpy(&nim->tuner.cx24108.tunerparms,tunerparms,sizeof(TUNERPARMS));
    return(True);
  }

  DRIVER_SetError(nim,API_BAD_PARM);
  return(False);

}  /* _Tuner_CX24108_setgainparms() */


/*******************************************************************************************************/
/* _TUNER_CX24108_band_info() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_band_info(    /* function to calc and return band-select prog bits to caller */
NIM            *nim,                        /* pointer to nim */
unsigned long  Fr,                          /* Fr (Freq. Receive) input */
unsigned int   *bandbin,                    /* binary bits to program band-select for Fr */
unsigned int   *vcodivbin,                  /* binary bit to program vco divider in band-select for Fr */
VCOSET         *vcoset,                     /* vco chosen for Fr */
VCODIV         *vcodiv,                     /* vco divider chosen for Fr */
VCONO          *vcono,                      /* vco number chosen (always 1..8) */
unsigned long  *tunpll)                     /* calculated generic tuner pll programming setting */
{
  int  i;
  int  j;
  int  start_pt;

  unsigned long  vco_len;
  unsigned long  srm;

  static VCONO  _vcono[] =  {(unsigned char)VCO1D2,(unsigned char)VCO2D2,(unsigned char)VCO3D2,(unsigned char)VCO4D2,(unsigned char)VCO5D2,(unsigned char)VCO6D2,
                             (unsigned char)VCO7D2,(unsigned char)VCO8D2,(unsigned char)VCO6D2,(unsigned char)VCO7D2,(unsigned char)VCO8D2};

  static VCONO  _vcosearchorder[] =
                            {(unsigned char)VCO1D2,(unsigned char)VCO2D2,(unsigned char)VCO3D2,(unsigned char)VCO4D2,
                             (unsigned char)VCO5D2,(unsigned char)VCO6D2,(unsigned char)VCO7D2,(unsigned char)VCO8D2,
                             (unsigned char)VCO8D4,(unsigned char)VCO7D4,(unsigned char)VCO6D4};

  static VCOSET _vcoset[] = {VCO1D2,VCO2D2,VCO3D2,VCO4D2,VCO5D2,VCO6D2,VCO7D2,VCO8D2,VCO6D4,VCO7D4,VCO8D4};
  static VCODIV _vcodiv[] = {VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV4,VCODIV4,VCODIV4};

  static unsigned int   _bandbin[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x20,0x40,0x80};
  static int    _vcodivbin[] = {-1,-1,1,-1,0};  /* 2=0x01, 4=0x00 */

  /* set the starting search pt.  If div/4, then start at the div/4 vcos */
  start_pt = CX24108_START_DIV2;
  if (nim->tuner.cx24108.vcodiv == VCODIV4)  start_pt = CX24108_START_DIV4;

  /* step through each VCO, examine for a valid VCO edge, if edge is not valid, generate a warning */
  for (j = 0 ; j < CX24108_VCOEDGES ; j++)
  {
    unsigned long  Fl = nim->tuner.cx24108.vco_edge[j].lower;
    unsigned long  Fh = nim->tuner.cx24108.vco_edge[j].upperthresh;

    if (Fl <= MAX_TUNER_VCOERROR || Fh <= MAX_TUNER_VCOERROR)
    {
      /* an invalid VCO edge was detected, flag as warning, then continue */
      DRIVER_SetError(nim,API_TUNERVCO);
    }
  }

  /* match Fr to vco edges, using high and low breakpoints, not actual edges */
  for (j = start_pt ; j < CX24108_VCOEDGES ; j++)
  {
    /* find a VCO by looking into 1/2 .. 8/2, then 8/4, 8/4, 6/4 vcos */
    i = _vcosearchorder[j];  /* remove this line if vco search s/b 1/2..8/2,6/4..8/4 */

    if (_TUNER_CX24108_vco_range(nim,Fr,i) == True)
    {
      int  idx;

      /* grab vcoset, vcodiv, return to caller */
      *vcono = (VCONO)(_vcono[i]+1);           /* returns VCO number before divider is set */
      *vcoset = _vcoset[i];                    /* returns actual VCOSET enum value */
      *vcodiv = _vcodiv[i];                    /* vco divider */
      *bandbin = _bandbin[i];                  /* band sel prog'd directly to cx24108 */
      *vcodivbin = (unsigned int)_vcodivbin[*vcodiv];  /* vcodiv prog'd directly to cx24108 */
      *tunpll = 0UL;

      /* compute current vco length */
      vco_len = nim->tuner.cx24108.vco_edge[i].upperthresh - nim->tuner.cx24108.vco_edge[i].lower;
     
      /* set cpc default current to mid level */
      nim->tuner.cx24108.CPCCurrent = (int)nim->tuner.cx24108.tunerparms.CPC[_vcono[*vcoset]].mid;

      /* is fr in lower percentage area (defined by tunerparms.low percentage)? */
      if (Fr < (nim->tuner.cx24108.vco_edge[i].lower+
         ((vco_len/100UL)*nim->tuner.cx24108.tunerparms.CPC[_vcono[*vcoset]].LowPercentage)))
      {
        nim->tuner.cx24108.CPCCurrent = (int)nim->tuner.cx24108.tunerparms.CPC[_vcono[*vcoset]].low;
      }
      else
      {
        if (Fr >= (nim->tuner.cx24108.vco_edge[i].lower+
           ((vco_len/100UL)*nim->tuner.cx24108.tunerparms.CPC[_vcono[*vcoset]].HighPercentage)))
        {
          nim->tuner.cx24108.CPCCurrent = (int)nim->tuner.cx24108.tunerparms.CPC[_vcono[*vcoset]].high;
        }
      }

      /* save tuner slope data into rosie (current settings) */
      idx = 0;
      srm = MM;
      if (nim->symbol_rate < MM)  srm = M;  
      if (nim->symbol_rate >= (1UL*srm) && nim->symbol_rate <= (5UL*srm))  idx = CX24108_MSPS_1_TO_5;
      else  if (nim->symbol_rate >= (5UL*srm) && nim->symbol_rate <= (15UL*srm))  idx = CX24108_MSPS_5_TO_15;
      else  if (nim->symbol_rate >= (15UL*srm) && nim->symbol_rate <= (45UL*srm))  idx = CX24108_MSPS_15_TO_45;
      
      nim->tuner.cx24108.VCASlope = nim->tuner.cx24108.tunerparms.SLP[idx].VCASlope;
      nim->tuner.cx24108.VCAOffset = nim->tuner.cx24108.tunerparms.SLP[idx].VCAOffset;
      nim->tuner.cx24108.VGA1Offset = nim->tuner.cx24108.tunerparms.SLP[idx].VGA1Offset;
      nim->tuner.cx24108.VGA2Offset = nim->tuner.cx24108.tunerparms.SLP[idx].VGA2Offset;
      return(True);
    }
  }

  /* this error number is set if a valid freq can not be found within the present VCO edges. */
  /* (default VCO edges might have been used) */
  DRIVER_SetError(nim,API_TUNERVCO);
  return(False);

}  /* _TUNER_CX24108_band_info() */


/*******************************************************************************************************/
/* _TUNER_CX24108_vco_range() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_vco_range(       /* function to test if Freq. requested is within vcoidx bounds */
NIM            *nim,                           /* pointer to nim */
unsigned long  Fr,                             /* frequency requested */
int            vcoidx)                         /* vco index */
{
  unsigned long  Ft;           /* Freq-test */
  unsigned long  Fl = nim->tuner.cx24108.vco_edge[vcoidx].lower;
  unsigned long  Fh = nim->tuner.cx24108.vco_edge[vcoidx].upperthresh;

  if (Fr >= Fl && Fr <= Fh)
  {
    /* test Fr against valid low range */
    Ft = _TUNER_CX24108_vco_low(nim,vcoidx);
    if (Fr < Ft)  return(False);
    
    Ft = _TUNER_CX24108_vco_high(nim,vcoidx);
    if (Fr > Ft)  return(False);
    return(True);
  }

  return(False);

}  /* _TUNER_CX24108_vco_range() */


/*******************************************************************************************************/
/* _TUNER_CX24108_vco_low() */
/*******************************************************************************************************/
unsigned long  _TUNER_CX24108_vco_low( /* function to return Fr low range based on vcoidx */
NIM            *nim,                   /* pointer to nim */
int            vcoidx)                 /* vco index */
{
  if (vcoidx >= 0)
  {
    switch(vcoidx)
    {
      case  0:
      {
        return(nim->tuner.cx24108.vco_bp[CX24108_BPCNT-1].breakpt);
        break;
      }
      case  1:
      case  2:
      case  3:
      case  4:
      case  5:
      case  6:
      case  7:
      {
        return(nim->tuner.cx24108.vco_bp[vcoidx-1].breakpt);
        break;
      }
      case  8:
      {
        return(nim->tuner.cx24108.vco_edge[vcoidx].lower);
        break;
      }
      case  9:
      {
        /* no other BP's to test, so return lowest freq tested */
        return(nim->tuner.cx24108.vco_bp[7].breakpt);
        break;
      }
      case  10:
      {
        return(nim->tuner.cx24108.vco_bp[8].breakpt);
        break;
      }
      default:
      {
        break;
      }
    }  /* switch(... */
  }

  return(0UL);

}  /* _TUNER_vco_low() */


/*******************************************************************************************************/
/* _TUNER_CX24108_vco_high() */
/*******************************************************************************************************/
unsigned long  _TUNER_CX24108_vco_high(/* function to return Fr high range based on vcoidx */
NIM            *nim,                   /* pointer to nim */
int            vcoidx)                 /* vco index */
{
  if (vcoidx >= 0)
  {
    switch(vcoidx)
    {
      case  0:
      case  1:
      case  2:
      case  3:
      case  4:
      case  5:
      case  6:
      {
        return(nim->tuner.cx24108.vco_bp[vcoidx].breakpt);
        break;
      }
      case  7:
      {
        return(nim->tuner.cx24108.vco_edge[vcoidx].upperthresh);
        break;
      }
      case  8:
      {
        /* (CR 7452) should return the current break pt. */
        return(nim->tuner.cx24108.vco_bp[7].breakpt);
        break;
      }
      case  9:
      {
        /* no other BP's to test, so return lowest freq tested */
        return(nim->tuner.cx24108.vco_bp[8].breakpt);
        break;
      }
      case  10:
      {
        return(nim->tuner.cx24108.vco_edge[vcoidx].upperthresh);
        break;
      }
      default:
      {
        break;
      }
    }  /* switch(... */
  }

  return(0UL);

}  /* _TUNER_vco_high() */


/*******************************************************************************************************/
/* _TUNER_CX24108_calc_bp() */
/*******************************************************************************************************/
void    _TUNER_CX24108_calc_bp(       /* calculates breakpoint values for nim's vco's */
NIM     *nim)                         /* pointer to nim */
{
  int    i;

  unsigned long   ulTemp;
  unsigned long   ulTemp2;
  long   diff;
  long   bp;

  /* build breakpoints for vcos: (1/2;2/3;3/4;4/5;5/6;6/7;7/8 )div2 -- count 7 */
  for (i = 0 ; i < 7 ; i++)
  {
    ulTemp =  (nim->tuner.cx24108.vco_edge[i].upperthresh/1000UL);
    ulTemp2 =  (nim->tuner.cx24108.vco_edge[i+1].lower/1000UL);
    diff = ulTemp - ulTemp2;
    bp = (diff * (long)nim->tuner.cx24108.vco_bp[i].percentage) / 100L;

    nim->tuner.cx24108.vco_bp[i].breakpt = ((unsigned long)bp * 1000UL);
    nim->tuner.cx24108.vco_bp[i].breakpt += nim->tuner.cx24108.vco_edge[i+1].lower;
  }

  /* use 6/D2 breakpoint div by two, for D/4 breakpoint */
  i = 7;
  nim->tuner.cx24108.vco_bp[i].breakpt = (nim->tuner.cx24108.vco_bp[5].breakpt/2UL);

  /* use 7/D2 breakpoint div by two, for D/4 breakpoint */
  i = 8;
  nim->tuner.cx24108.vco_bp[i].breakpt = (nim->tuner.cx24108.vco_bp[6].breakpt/2UL);

  /* manually build breakpoint for vco 8/0 div4 -- count 1 */
  i = CX24108_BPCNT-1;

  ulTemp =  (nim->tuner.cx24108.vco_edge[i+1].upperthresh/1000UL);
  ulTemp2 =  (nim->tuner.cx24108.vco_edge[0].lower/1000UL); 
  if (ulTemp2 < (unsigned long)(1075UL*M))  ulTemp2 = (unsigned long)(1075UL*M);
  diff = ulTemp - ulTemp2;
  bp = (diff * (long)nim->tuner.cx24108.vco_bp[i].percentage) / 100L;

  nim->tuner.cx24108.vco_bp[i].breakpt = ((unsigned long)bp * 1000UL);
  nim->tuner.cx24108.vco_bp[i].breakpt += (nim->tuner.cx24108.vco_edge[0].lower);

  return;

}  /* _TUNER_CX24108_calc_bp() */


/*******************************************************************************************************/
/* _TUNER_CX24108_adjust() */
/*******************************************************************************************************/
void  _TUNER_CX24108_adjust(           /* adjusts VCO table, disallows vco below 2150 MHz */
NIM   *nim)                            /* nim pointer */
{
  if (nim == (NIM*)NULL)  return;

  /* adjust lower edge of vco 0 -- disallow use of this vco if freq is below 1075 */
  /* REMOVED per CR 7878 */
  /* if (nim->tuner.cx24108.vco_edge[0].lower < (unsigned long)(1075UL*MM))  */
  /* nim->tuner.cx24108.vco_edge[0].lower = (unsigned long)(1075UL*MM);  */

  return;

}  /* _TUNER_CX24108_adjust() */


/*******************************************************************************************************/
/* _TUNER_CX24108_hardware_vcoedges() */
/*******************************************************************************************************/
BOOL  _TUNER_CX24108_hardware_vcoedges(/* calculates vco edges via bs-like algo */
NIM   *nim)                            /* pointer to nim */
{
  int     vcoidx;
  int     CPCCurrent;
  unsigned long   low_edge;
  unsigned long   high_edge;
  unsigned long   first_edge;    /* returned from low edge detection */

  /* set the default settings */
  _TUNER_CX24108_initialize(nim);

  /* save the current CPC setting to be restored after edge detection is done */
  CPCCurrent = nim->tuner.cx24108.CPCCurrent;

  /* step through each vco using index.  stop after last vco (VCO8D4) is processed */
  for (vcoidx = 0 ; vcoidx < (VCO8D2+1) ; vcoidx++)  /* (CR 7453) was VCO8DIV4) */
  {
    /* grab the low-edge */
    low_edge = _TUNER_CX24108_hardware_vcoedge_low(nim,vcoidx,&first_edge);
    nim->frequency = 0UL;
    /* nim->tuner.cx24108.vco_edge[vcoidx].lower = 0UL;*/          /* cr 7452 */
    if (low_edge != 0UL)  nim->tuner.cx24108.vco_edge[vcoidx].lower = low_edge;
    if (low_edge == 0UL)  return(False);

    /* grab the high-edge */
    high_edge = _TUNER_CX24108_hardware_vcoedge_high(nim,vcoidx,low_edge,first_edge,nim->tuner.cx24108.vco_len[vcoidx]);
    nim->frequency = 0UL;
    /* nim->tuner.cx24108.vco_edge[vcoidx].upperthresh = 0UL;*/    /* cr 7452 */
    if (high_edge != 0UL)  nim->tuner.cx24108.vco_edge[vcoidx].upperthresh = high_edge;
    if (high_edge == 0UL)  return(False);
  }

  /* restore the CPC setting */
  nim->tuner.cx24108.CPCCurrent = CPCCurrent;

  /* (CR 7453) vco edges calculated for DIV2 are valid for DIV4 edges */
  nim->tuner.cx24108.vco_edge[VCO6D4].lower = nim->tuner.cx24108.vco_edge[VCO6D2].lower/2UL;
  nim->tuner.cx24108.vco_edge[VCO6D4].upperthresh = nim->tuner.cx24108.vco_edge[VCO6D2].upperthresh/2UL;

  nim->tuner.cx24108.vco_edge[VCO7D4].lower = nim->tuner.cx24108.vco_edge[VCO7D2].lower/2UL;
  nim->tuner.cx24108.vco_edge[VCO7D4].upperthresh = nim->tuner.cx24108.vco_edge[VCO7D2].upperthresh/2UL;

  nim->tuner.cx24108.vco_edge[VCO8D4].lower = (nim->tuner.cx24108.vco_edge[VCO8D2].lower/2UL);
  nim->tuner.cx24108.vco_edge[VCO8D4].upperthresh = (nim->tuner.cx24108.vco_edge[VCO8D2].upperthresh/2UL);

  /* re-cal bp after vco edges detected */
  _TUNER_CX24108_calc_bp(nim);

  /* adjust pre-set vco's if below 2150/2 */
  _TUNER_CX24108_adjust(nim);

  return(True);

}  /* _TUNER_CX24108_hardware_vcoedges() */


/*******************************************************************************************************/
/* _TUNER_CX24108_hardware_vcoedge_low() */
/*******************************************************************************************************/
unsigned long  _TUNER_CX24108_hardware_vcoedge_low(        /* find vco's low edge */
NIM            *nim,                                       /* nim pointer */
int            vcoidx,                                     /* vco idx number to find edge of */
unsigned long  *first_edge)                                /* returns computed "middle" of detected vco */
{
  int    done = False;
  int    counter;
  int    pllerrcnt = 0; 
  int    loopcnt = 0;

  unsigned long  mid_pt;
  unsigned long  lowest_pt;
  unsigned long  test_pt;
  unsigned long  ulTemp;                     /* unused: holds return state only */

  BOOL   locked;
  BOOL   fm;

  mid_pt = (nim->tuner.cx24108.vco_edge[vcoidx].upperthresh - nim->tuner.cx24108.vco_edge[vcoidx].lower)/2UL;
  mid_pt += nim->tuner.cx24108.vco_edge[vcoidx].lower;

  /* use 2mA CPC current for low edge detection */
  nim->tuner.cx24108.CPCCurrent = CX24108_CPC_LOW;

  /* find the "mid-point" of vco to test edge of.  (This MUST lock!) (CR 7452 changed below line to return 1 on fail) */
  if (_TUNER_CX24108_first_edgelock(nim,&mid_pt,&locked,(VCOSET)vcoidx) == False)  return(TUNER_VCOERROR_ONE);
  *first_edge = mid_pt;

  /* we've locked first time into the "middle" of a good band, so start the search */
  lowest_pt = mid_pt;
  while ((locked == True) && (loopcnt < CX24108_MAX_LOOP))
  {
	loopcnt++;
    /* adjust lowest pt. with big jumps, set freq, get lock status */
    /* when lock is lost, this is max bounds */
    lowest_pt -= (CX24108_NOMSTEP*CX24108_EDGESTEP);
    fm = _TUNER_CX24108_freq_manual(nim,lowest_pt);
    ulTemp = _TUNER_CX24108_vcoband_manual(nim,vcoidx);
    if (_TUNER_CX24108_pll_status(nim,&locked) == False)  pllerrcnt++;
  }
 
  /* Check if hardware is stuck. */
  if (loopcnt == CX24108_MAX_LOOP) 
  {
    return(TUNER_VCOERROR_ZERO);
  }

  /* recalc mid-pt  */
  mid_pt = lowest_pt + (CX24108_NOMSTEP*CX24108_EDGESTEP);
      
  /* mid_pt is highest last known lock position;  lowest_pt is past known boundary, so we have binary search bounds */
  /* so perform bin search to catch edge */
  done = False;
  counter = 0;
  while (done == False)
  {
    test_pt = mid_pt - ((mid_pt-lowest_pt)/2UL);
    fm = _TUNER_CX24108_freq_manual(nim,test_pt);
    ulTemp = _TUNER_CX24108_vcoband_manual(nim,vcoidx);
    if (_TUNER_CX24108_pll_status(nim,&locked) == False)  pllerrcnt++;

    if (locked == True)  mid_pt = test_pt;
    else  lowest_pt = test_pt;
        
    /* bail if we're within the ballpark of the edge */
    if ((mid_pt-lowest_pt) < CX24108_MINHILOWDIST)  return(mid_pt);

    counter++;
    if (counter > CX24108_MAX_EDGEDIV)  done = True;
  }

  /* not successful finding middle-point of band (i.e. could not start) */
  return(TUNER_VCOERROR_ZERO);

}  /* _TUNER_CX24108_hardware_vcoedge_low() */


/*******************************************************************************************************/
/* _TUNER_CX24108_hardware_vcoedge_high() */
/*******************************************************************************************************/
unsigned long  _TUNER_CX24108_hardware_vcoedge_high(    /* find vco's low edge */
NIM            *nim,                                    /* nim pointer */
int            vcoidx,                                  /* vco idx number to find edge of */
unsigned long  low_edge,                                /* low-edge found (used in high-edge start calc) */
unsigned long  first_edge,                              /* first-edge found when low-edge detected (used in high-edge calc) */
unsigned long  vco_len)                                 /* estimated length of this vco */
{
  int    done = False;
  int    counter;
  int    pllerrcnt = 0; 
  int    loopcnt = 0;

  unsigned long  mid_pt;
  unsigned long  highest_pt;
  unsigned long  test_pt;
  unsigned long  ulTemp;              /* unused: holds return state only */

  BOOL   locked = True;
  BOOL   fm;

  /* if neither potential edge is valid, we have a serious error.  (save and bail) */
  if ((low_edge <= MAX_TUNER_VCOERROR && first_edge <= MAX_TUNER_VCOERROR) /* || (vco_len < 0) */)  return(TUNER_VCOERROR_TWO);

  /* use 3mA CPC current for high edge detection */
  nim->tuner.cx24108.CPCCurrent = CX24108_CPC_HIGH;

  /* Use a known good start point to do the high edge search. */
  mid_pt = first_edge;

  /* we've locked first time into the middle of a good band, so start the search */
  highest_pt = mid_pt;
  while ((locked == True) && (loopcnt < CX24108_MAX_LOOP))
  {
    loopcnt++;
    /* adjust highest pt., set freq, get lock status */
    highest_pt += (CX24108_NOMSTEP*CX24108_EDGESTEP);
    fm = _TUNER_CX24108_freq_manual(nim,highest_pt);
    ulTemp = _TUNER_CX24108_vcoband_manual(nim,vcoidx);
    if (_TUNER_CX24108_pll_status(nim,&locked) == False)  pllerrcnt++;
  }

  /* Check if hardware is stuck. */
  if (loopcnt == CX24108_MAX_LOOP) 
  {
    return(TUNER_VCOERROR_ZERO);
  }

  /* recalc mid-pt (so edge is between mid_pt and highest_pt) */
  mid_pt = highest_pt - (CX24108_NOMSTEP*CX24108_EDGESTEP);

  /* now we have our binary search bounds, so perform bin search to catch edge */
  done = False;
  counter = 0;
  while (done == False)
  {
    test_pt = mid_pt + ((highest_pt-mid_pt)/2UL);
    fm = _TUNER_CX24108_freq_manual(nim,test_pt);
    ulTemp = _TUNER_CX24108_vcoband_manual(nim,vcoidx);
    if (_TUNER_CX24108_pll_status(nim,&locked) == False)  pllerrcnt++;
 
    if (locked == True)  mid_pt = test_pt;
    else  highest_pt = test_pt;
        
    /* bail if we're within the ballpark of the edge */
    if ((highest_pt-mid_pt) < CX24108_MINHILOWDIST)
    {
      done = True;
      return(mid_pt);
    }
    counter++;
    if (counter > CX24108_MAX_EDGEDIV)  done = True;
  }

  /* not successful finding middle-point of band (i.e. could not start) */
  return(TUNER_VCOERROR_ZERO);
}  /* _TUNER_CX24108_hardware_vcoedge_high() */


/*******************************************************************************************************/
/* _TUNER_CX24108_vcoband_manual() */
/*******************************************************************************************************/
unsigned long  _TUNER_CX24108_vcoband_manual(  /* function to manually set the tuner band selection programming bits */
NIM            *nim,                           /* pointer to nim */
int            vcoband)                        /* vco number (0..10) to set tuner to */
{
  int  err = 0;

  unsigned long  ulRegVal;
  unsigned int   vcodivbin;
  unsigned int   bandbin;

  static VCODIV        _vcodiv[] = {VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV2,VCODIV4,VCODIV4,VCODIV4};
  static unsigned int  _bandbin[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x20,0x40,0x80};
  static int           _vcodivbin[] = {-1,-1,1,-1,0};  /* 2=0x01, 4=0x00 */

  /* disallow invalid band setting */
  if (vcoband >= CX24108_VCOEDGES)  return(0UL);

  vcodivbin = (unsigned int)_vcodivbin[_vcodiv[vcoband]];
  bandbin = _bandbin[vcoband];

  ulRegVal = vcodivbin;
  ulRegVal <<= 9;
  ulRegVal |= bandbin;
  if (_TUNER_CX24108_io(nim,CX24108_BAND_PROG,ulRegVal) == False)  err++;
  
  return(ulRegVal);

}  /* _TUNER_CX24108_vcoband_manual() */

 
/*******************************************************************************************************/
/* _TUNER_CX24108_first_edgelock() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_first_edgelock(  /* Function to find the first-lock position of vco edges detect */
NIM            *nim,                           /* pointer to nim */
unsigned long  *mid_pt,                        /* point at which initial edge detection will start */
BOOL           *locked,                        /* returns True if locked, (if False, error:  failure to find initial edge) */
VCOSET         vcoband)                        /* vco band number being scanned */
{
  int    i;

  if (__TUNER_CX24108_first_edgeone(nim,mid_pt,locked,vcoband) == True)  return(True);

  /* find the first edge manually, return True when found */
  for (i = 1 ; i < CX24108_MAX_FIRSTEDGE+1 ; i++)
  {
    *mid_pt += (i * (CX24108_NOMSTEP * CX24108_EDGESTEP));
    if (__TUNER_CX24108_first_edgeone(nim,mid_pt,locked,vcoband) == True)  return(True);
    *mid_pt -= (i * (CX24108_NOMSTEP * CX24108_EDGESTEP));

    *mid_pt -= (i * (CX24108_NOMSTEP * CX24108_EDGESTEP));
    if (__TUNER_CX24108_first_edgeone(nim,mid_pt,locked,vcoband) == True)  return(True);
    *mid_pt += (i * (CX24108_NOMSTEP * CX24108_EDGESTEP));
  }

  /* unable to find a reasonable vco edge */
  DRIVER_SetError(nim,API_TUNEREDGE);
  return(False);

}  /* _TUNER_CX24108_first_edgelock() */


/*******************************************************************************************************/
/* __TUNER_CX24108_first_edgeone() */
/*******************************************************************************************************/
BOOL           __TUNER_CX24108_first_edgeone(  /* Function to find the first-lock position of vco edges detect */
NIM            *nim,                           /* pointer to nim */
unsigned long  *mid_pt,                        /* point at which initial edge detection will start */
BOOL           *locked,                        /* returns True if locked, (if False, error:  failure to find initial edge) */
VCOSET         vcoband)                        /* vco band number being scanned */
{
  int    vcoidx = (int)vcoband;          /* vco idx (0..n) is passed to funct (vcoidx indicates VCOSET index into vco struct) */

  unsigned long  bm;                     /* band manual return */

  /* change freq, test lock */
  if (_TUNER_CX24108_freq_manual(nim,*mid_pt) == False)  return(False);
  bm = _TUNER_CX24108_vcoband_manual(nim,vcoidx);
  if (_TUNER_CX24108_pll_status(nim,locked) == False)  return(False);

  if (*locked == True)
  {
    /* successful tune, and pll lock */
    return(True);
  }
    
  return(False);

}  /* __TUNER_CX24108_first_edgeone() */


/*******************************************************************************************************/
/* _TUNER_CX24108_pll_status( */
/*******************************************************************************************************/
BOOL  _TUNER_CX24108_pll_status(       /* reads current tuner pll lock status */
NIM   *nim,                            /* nim pointer */
BOOL  *locked)                         /* BOOL pointer, where tuner pll lock status is returned */
{
  unsigned long  ulRegVal;

  /* Lock assertion from tuner takes a short time. */
  OS_Wait(nim,1);

  /* read the demod's tuner lock indicator pin */
  if (RegisterRead(nim,CX24130_TUNPLLLOCK,&ulRegVal) == False)  return(False);

  if (ulRegVal == 0UL)  *locked = False;
  else  *locked = True;

  return(True);

}  /* _TUNER_CX24108_pll_status() */


/*******************************************************************************************************/
/* _TUNER_CX24108_set_registers() */
/*******************************************************************************************************/
BOOL     _TUNER_CX24108_set_registers( /* function to set N, A, R registers in tuner */
NIM      *nim,                         /* pointer to nim */
int      nvalue,                       /* N register */
int      avalue,                       /* A register */
RDIVVAL  rvalue)                       /* R register */
{
  int     na;

  unsigned int    bandbin;
  unsigned int    vcodivbin;
  unsigned long   tunpll;
  unsigned long   ulRegVal;
  unsigned long   Fr;

  VCOSET  vcoset;             /* vco number vai VCOSET enum:  VCO1D2 (aka VCO #1) .. VCO8D4 (aka VCO #11) */
  VCONO   vcono;              /* vco number: always one of: 1,2,3,4,5,6,7,8 */
  VCODIV  vcodiv;

  /* convert the rvalue into value to be programmed to the tuner */
  if (_TUNER_CX24108_set_refdivider(nim,rvalue) == False)  return(False);

  /* save last n,a,r settings */
  nim->tuner.cx24108.N = nvalue;
  nim->tuner.cx24108.A = avalue;
  nim->tuner.cx24108.R = rvalue;

  /* determine frequency */
  ulRegVal = ((unsigned long)nvalue<<5)|(unsigned long)avalue;
  na = (int)ulRegVal;
  Fr = _TUNER_CX24108_calc_Fpll(nim,na);

  /* (CR 7795) */
  nim->frequency = Fr;

  /* set the tuner band-select bit settings */
  if (_TUNER_CX24108_band_info(nim,Fr,&bandbin,&vcodivbin,&vcoset,&vcodiv,&vcono,&tunpll) == False)  return(False);
  ulRegVal = ((unsigned long)vcodivbin<<9);
  ulRegVal |= (unsigned long)bandbin;
  if (_TUNER_CX24108_io(nim,CX24108_BAND_PROG,ulRegVal) == False)  return(False);

  /* continue building data to send to tuner (via demod) */
  ulRegVal = ((unsigned long)nim->tuner.cx24108.RefDivider<<17UL);                     /* R Divider */
  ulRegVal |= ((unsigned long)nim->tuner.cx24108.CPCPolarity<<16UL);  /* charge pump polarity */
  ulRegVal |= (((unsigned long)nim->tuner.cx24108.CPCCurrent&0x03UL)<<CX24108_CPC_START);
  ulRegVal |= (((unsigned long)nvalue&0x1ffUL)<<5UL);
  ulRegVal |= ((unsigned long)avalue&0x1fUL);

  /* send built "string" to the tuner */
  if (_TUNER_CX24108_io(nim,CX24108_PLL_PROG,ulRegVal) == False)  return(False);

  return(True);

}  /* _TUNER_CX24108_set_registers() */


/*******************************************************************************************************/
/* _TUNER_CX24108_set_refdivider() */
/*******************************************************************************************************/
BOOL     _TUNER_CX24108_set_refdivider(/* function to set the ref divider value prog'd to the tuner */
NIM      *nim,                         /* pointer to nim (nim->RefDivider is set within nim) */
RDIVVAL  rvalue)                       /* ref divider value (10,20...) */
{
  int  i;

  static unsigned char  _rvalue[] = {0x03,0x02, 0x01, 0x00};  /* value programmed to tuner */
  static RDIVVAL        rvalue_match[] = {RDIV_10,RDIV_20,RDIV_40,RDIV_UNDEF};

  /* find the correct rvalue setting for the tuner */
  for (i = 0 ; rvalue_match[i] != RDIV_UNDEF ; i++)
  {
    if (rvalue_match[i] == rvalue)
    {
      nim->tuner.cx24108.RefDivider = _rvalue[i];
      return(True);
    }
  }

  /* unable to equate rvalue to tuner setting */
  DRIVER_SetError(nim,API_BAD_CXDATA);
  return(False);

}  /* _TUNER_CX24108_set_refdivider() */


/*******************************************************************************************************/
/* __TUNER_CX24108_set_freq() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_set_freq(/* set tuner to a desired frequency */
NIM            *nim,                   /* pointer to nim */
unsigned long  freq)                   /* frequency in khz to set tuner to */
{
  unsigned int   bandbin;
  unsigned int   vcodivbin;

  unsigned long  ulRegVal;
  unsigned long  nar_str;              /* string of bits to be written to tuner */
  unsigned long  tunpll;

  BOOL     rtn1;
  BOOL     rtn2;
  BOOL     rtn3;

  VCOSET  vcoset;             /* vco number via VCOSET enum:  VCO1D2 (aka VCO #1) .. VCO8D4 (aka VCO #11) */

  /* default:  set the frequency, rdiv, vcodiv */
  nim->frequency = freq;
  nim->tuner.cx24108.vcodiv = VCODIV2;

  /* special op to set freq 1mhz high */
  _TUNER_CX24108_io_special(nim);

  /* set the tuner band-select bit settings, plus set add'l tuner settings */
  rtn1 = _TUNER_CX24108_band_info(nim,nim->frequency,&bandbin,&vcodivbin,&vcoset,
    &nim->tuner.cx24108.vcodiv,&nim->tuner.cx24108.vcono,&tunpll);
  
  /* set VCO divider and band-select data */
  ulRegVal = vcodivbin;
  ulRegVal <<= 9;
  ulRegVal |= bandbin;
  rtn2 = _TUNER_CX24108_io(nim,CX24108_BAND_PROG,ulRegVal);

  /* write the pll setting to the tuner */
  nar_str = _TUNER_CX24108_calc_pll(nim);

  ulRegVal = nar_str;
  ulRegVal |= ((unsigned long)nim->tuner.cx24108.RefDivider<<17);   /* ref divider programming bits */
  ulRegVal |= ((unsigned long)nim->tuner.cx24108.CPCPolarity<<16);  /* charge pump polarity */
  ulRegVal |= (((unsigned long)nim->tuner.cx24108.CPCCurrent&0x03UL)<<CX24108_CPC_START);
  
  rtn3 = _TUNER_CX24108_io(nim,CX24108_PLL_PROG,ulRegVal);
  
  if (rtn1 != True || rtn2 != True || rtn3 != True)  return(False);
  return(True);

}  /* __TUNER_CX24108_set_freq() */


/*******************************************************************************************************/
/* _TUNER_CX24108_calc_pll() */
/*******************************************************************************************************/
unsigned long  _TUNER_CX24108_calc_pll(/* function to calc pll settings (n,a) using bcd functions */
NIM            *nim)                   /* nim pointer */
{
  unsigned long  NA;

  NA = _TUNER_CX24108_calc_pllNA(nim);

  /* save the last NAR settings */
  nim->tuner.cx24108.N = (int)((NA&0x3fffUL)>>5UL);
  nim->tuner.cx24108.A = (int)(NA&0x1fUL);

  /* this calculated N, A value is what is physically sent to the tuner                      */
  /* the tuner has a feature where when A is zero, it tunes significantly above              */
  /* the calculated PLL freq.  DO NOT USE THIS NA return value to perform calculations       */ 

  /* if the a portion of NA is zero, subtract 1 to n portion */
  if ((NA&0x1fUL) == 0UL)
  {
    NA -= 32UL;
  }

  return(NA);

}  /* _TUNER_CX24108_calc_pll() */


/*******************************************************************************************************/
/* _TUNER_CX24108_calc_pllNA() */
/*******************************************************************************************************/
unsigned long  _TUNER_CX24108_calc_pllNA(      /* function to calc pll settings (n,a) using bcd functions */
NIM            *nim)                           /* nim pointer */
{
  unsigned long  NA;

  /* set freq to a default setting, if not presently set, test xtal for zero before divide (CR 7452) */
  if (nim->frequency == 0UL)  nim->frequency = NIM_DEFAULT_FREQ;
  if (nim->crystal_freq == 0UL)  nim->crystal_freq = NIM_DEFAULT_XTAL;

  NA = (nim->frequency / 100UL) * ((unsigned long)nim->tuner.cx24108.R * (unsigned long)nim->tuner.cx24108.vcodiv);
  NA /= ((nim->crystal_freq / M) * 2UL);
  NA += 5UL;
  NA /= 10UL;

  return(NA);

}  /* _TUNER_CX24108_calc_pllNA() */


/*******************************************************************************************************/
/* _TUNER_CX24108_calculateNAR() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_CalculateNAR(      /* function to calc pll settings (n,a) using bcd functions */
NIM            *nim,                             /* nim pointer */
unsigned long  Fdesired,                         /* desired frequency */
RDIVVAL        R,                                /* proposed reference divider */
unsigned int   *N,                               /* returned N value */
unsigned int   *A)                               /* returned A value */
{
  unsigned long  NA;
  BCDNO          bcd;

  /* calculate tuner PLL settings: */
  BCD_set(&bcd,Fdesired);
  BCD_mult(&bcd,((unsigned long)R * (unsigned long)nim->tuner.cx24108.vcodiv * M));
  BCD_div(&bcd,(nim->crystal_freq * 2UL));
 
  NA = BCD_out(&bcd);
  NA += 500UL;
  NA /= 1000UL;

  *N = (int)((NA&0x3fffUL)>>5UL);
  *A = (int)(NA&0x1fUL);

  return(True);

}  /* _TUNER_CX24108_CalculateNAR() */


/*******************************************************************************************************/
/* _TUNER_CX24108_SetGainSettings() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_SetGainSettings( /* function to set the VCA, VGA settings for CX24108 tuner */
NIM            *nim,                           /* pointer to nim */
unsigned long  symbolrateksps)                 /* symbol rate determines the VCA, VGA settings */
{
   VCASLOPE  VCASlope;
   VCAOFFSET VCAOffset;
   VGA1VALS  VGA1Offset;
   VGA2VALS  VGA2Offset;

   unsigned long  ulRegVal;
   int idx;

   /* get tuner's VCA and VGA settings from NIM for the given symbol rate */
#ifdef CAMARIC_FEATURES
   if (symbolrateksps < 5000UL)
   {
      idx = CX24108_MSPS_1_TO_5;
   }
   else
#endif  /* #ifdef CAMARIC_FEATURES */
   if (symbolrateksps < 15000UL)
   {
      idx = CX24108_MSPS_5_TO_15;
   }
   else
   {
      idx = CX24108_MSPS_15_TO_45;
   }

   VCASlope = nim->tuner.cx24108.tunerparms.SLP[idx].VCASlope;
   VCAOffset = nim->tuner.cx24108.tunerparms.SLP[idx].VCAOffset;
   VGA1Offset = nim->tuner.cx24108.tunerparms.SLP[idx].VGA1Offset;
   VGA2Offset = nim->tuner.cx24108.tunerparms.SLP[idx].VGA2Offset;

   /* program tuner's VCA settings */
   ulRegVal =  VCASlope | (VCAOffset << 9);
   if (_TUNER_CX24108_io(nim,CX24108_VCA_PROG,ulRegVal) == False)
   {
      return (False);
   }

   /* program tuner's VGA settings */
   ulRegVal = VGA1Offset | (VGA2Offset << 9);
   if (_TUNER_CX24108_io(nim,CX24108_VGA_PROG,ulRegVal) == False)
   {
      return (False);
   }

   return (True);

}  /* _TUNER_CX24108_SetGainSettings() */


/*******************************************************************************************************/
/* _TUNER_CX24108_calc_Fpll() */
/*******************************************************************************************************/
unsigned long  _TUNER_CX24108_calc_Fpll(       /* function to calculate the tuner pll freq using N,A reg settings */
NIM            *nim,                           /* pointer to nim */
int            na)                             /* N,A register (9MSB=N, 5LSB=a register) */
{
  unsigned long  ulTemp;
  RDIVVAL   r = nim->tuner.cx24108.R;

  if (r != RDIV_10 && r != RDIV_20 && r != RDIV_40)  r = RDIV_10;

  if (DRIVER_div_zero(nim,na) == False)  return(False);
  ulTemp = (nim->crystal_freq / (unsigned long)r) * ((unsigned long)na);
  if (nim->tuner.cx24108.vcodiv != VCODIV2)
  {
    ulTemp++;
    ulTemp /= 2UL;
  }

  return(ulTemp);

}  /* _TUNER_CX24108_calc_Fpll() */



/*******************************************************************************************************/
/* __TUNER_CX24108_freq_manual() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_freq_manual(     /* set tuner to a desired frequency */
NIM            *nim,                           /* pointer to nim */
unsigned long  freq)                           /* frequency in khz to set tuner to */
{
  unsigned int   n;
  unsigned long  ulRegVal;
  unsigned long  nar_str;              /* string of bits to be written to tuner */

  /* default:  set the frequency, rdiv, vcodiv */
  nim->frequency = freq;
  if (_TUNER_CX24108_set_refdivider(nim,nim->tuner.cx24108.R) == False)  return(False);
  nar_str = _TUNER_CX24108_calc_pll(nim);
  nim->tuner_nar = nar_str;

  /* see if PLL can be loaded with a "better" value giving better performance */
  ulRegVal = (nar_str&0x3fffUL)>>5UL;
  n = (unsigned int)ulRegVal;

  /* write the pll setting to the tuner */
  ulRegVal = nar_str;
  ulRegVal |= ((unsigned long)nim->tuner.cx24108.RefDivider<<17UL);   /* ref divider programming bits */
  ulRegVal |= ((unsigned long)nim->tuner.cx24108.CPCPolarity<<16UL);  /* charge pump polarity */
  ulRegVal |= (((unsigned long)nim->tuner.cx24108.CPCCurrent&0x03UL)<<CX24108_CPC_START);
  
  if (_TUNER_CX24108_io(nim,CX24108_PLL_PROG,ulRegVal) == False)  return(False);
  
  return(True);

}  /* __TUNER_CX24108_freq_manual() */


/*******************************************************************************************************/
/* _TUNER_CX24108_GetType() */
/*******************************************************************************************************/
BOOL     _TUNER_CX24108_GetType(       /* retrieve s tuner-type (enum TUNER) associated to nim */
NIM      *nim,                         /* pointer to NIM struct */
TUNER    *tunertype)                   /* contains returned tuner-type (enum TUNER) on function exit */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  *tunertype = nim->tuner_type;
  return(True);

}  /* _TUNER_CX24108_GetType() */


/*******************************************************************************************************/
/* _TUNER_CX24108_SetType() */
/*******************************************************************************************************/
BOOL     _TUNER_CX24108_SetType(       /* Sets the tuner-type (enum TUNER) associated to nim */
NIM      *nim)                         /* pointer to NIM struct */
{
  nim->tuner_type = CX24108;
  return(True);

}  /* _TUNER_CX24108_SetType() */


/*******************************************************************************************************/
/* _TUNER_CX24108_getvco() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_getvco(  /* Funct to retrieve  the last vco number used to tuning operation */
NIM            *nim,                   /* pointer to nim */
unsigned char  *vcono)                 /* vco number */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  *vcono = nim->tuner.cx24108.vcono;
  return(True);

}/* _TUNER_CX24108_getvco() */


/*******************************************************************************************************/
/* _TUNER_CX_24108_SetReferenceDivider() */
/*******************************************************************************************************/
BOOL     _TUNER_CX24108_SetReferenceDivider(  /* sets the current reference divider value */
NIM      *nim,                                /* pointer to nim */
RDIVVAL  rvalue)                              /* reference divider value */
{
  unsigned int  N;
  unsigned int  A;

  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  switch(rvalue)
  {
    case  RDIV_10:
    case  RDIV_20:
    case  RDIV_40:
    {
      /* re-calculate where N,A should be set, if the R value changed */
      if (_TUNER_CX24108_CalculateNAR(nim,nim->frequency,rvalue,&N,&A) == False)  return(False);

      /* save last n,a,r settings */
      nim->tuner.cx24108.N = N;
      nim->tuner.cx24108.A = A;
      nim->tuner.cx24108.R = rvalue;
      
      /* set the ref divider bit mask that is sent to the tuner */
      if (_TUNER_CX24108_set_refdivider(nim,rvalue) == True)  break;
    }
    default:
    {
      DRIVER_SetError(nim,API_TUNERREF);
      return(False);
      break;
    }
  }  /* switch(... */

  return(True);

}  /* TUNER_CX24108_SetReferenceDivider() */


/*******************************************************************************************************/
/* _TUNER_CX24108_GetVcoDivider() */
/*******************************************************************************************************/
BOOL     _TUNER_CX24108_GetVcoDivider( /* gets the current vco divider, returns value to caller */
NIM      *nim,                         /* pointer to nim */
VCODIV   *vcodiv)                      /* vco divider value */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  *vcodiv = nim->tuner.cx24108.vcodiv;
  return(True);

}  /* _TUNER_CX24108_GetVcoDivider() */


/*******************************************************************************************************/
/* _TUNER_CX24108_GetReferenceDivider() */
/*******************************************************************************************************/
BOOL      _TUNER_CX24108_GetReferenceDivider(   /* retrieve s current reference divider value */
NIM       *nim,                                 /* pointer to nim */
RDIVVAL   *rvalue)                              /* pointer to RDIVVAL where value is returned to caller */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);
  
  *rvalue = nim->tuner.cx24108.R;
  return(True);

}  /* _TUNER_CX24108_GetReferenceDivider() */


/*******************************************************************************************************/
/* _TUNER_CX24108_GetPLLFrequency() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_GetPLLFrequency( /* returns current freq. programmed into the tuner pll register */
NIM            *nim,                           /* pointer to nim */
unsigned long  *pllfreq)                       /* pointer to unsigned long where pll freq. in Hz. will be returned */
{
  int      NA;           /* value programmed to the tuner -- do not use to determine pll freq */
  int      na;           /* computed value BEFORE adjustment to accomodate Rosie tuner */

  if (_TUNER_CX24108_validate(nim) == False)  return(False);
  
  *pllfreq = 0UL;
  NA = (int)_TUNER_CX24108_calc_pll(nim);
  na = (int)((((unsigned long)nim->tuner.cx24108.N&0x1ffUL)<<5)|((unsigned long)nim->tuner.cx24108.A&0x1fUL));
  *pllfreq = _TUNER_CX24108_calc_Fpll(nim,na);
  
  return(True);

}  /* _TUNER_CX24108_GetPLLFrequency() */


/*******************************************************************************************************/
/* TUNER_CX24108_GetRegisters() */
/*******************************************************************************************************/
BOOL     _TUNER_CX24108_GetRegisters(  /* function to retrieve  N, A, R values last sent to the tuner */
NIM      *nim,                         /* nim pointer */
int      *nvalue,                      /* pointer to int, where n value will be returned to caller */
int      *avalue,                      /* pointer to int, where a ... */
RDIVVAL  *rvalue)                      /* pointer to RDIVVAL, where r value will be returned */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  *nvalue = nim->tuner.cx24108.N;
  *avalue = nim->tuner.cx24108.A;
  *rvalue = nim->tuner.cx24108.R;
      
  /* r must be valid, if not, force to default value */
  if (*rvalue != RDIV_10 && *rvalue != RDIV_20 && *rvalue != RDIV_40)  *rvalue = RDIV_10;

  return(True);

}  /* _TUNER_CX24108_GetRegisters() */


/*******************************************************************************************************/
/* TUNER_CX24108_GetParameters() */
/*******************************************************************************************************/
BOOL        _TUNER_CX24108_GetParameters(  /* returns current tuner parameter settings to the caller */
NIM         *nim,                          /* pointer to nim */
TUNERPARMS  *tunerparms)                   /* pointer to TUNERPARMS, where copy will be written */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  if (tunerparms == NULL)  return(False);

  /* copy tunerparms to caller storage */
  memcpy(tunerparms,&nim->tuner.cx24108.tunerparms,sizeof(TUNERPARMS));
  return(True);

}  /* TUNER_GetParameters() */


/*******************************************************************************************************/
/* _TUNER_CX24108_SetParameters() */
/*******************************************************************************************************/
BOOL        _TUNER_CX24108_SetParameters( /* sets current TUNERPARMS struct in nim to that passed by caller */
NIM         *nim,                         /* pointer to nim */
TUNERPARMS  *tunerparms)                  /* copy of TUNERPARMS to use as default */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  if (tunerparms == NULL)  return(False);

  /* copy from user-buffer to tuner buffer */
  memcpy(&nim->tuner.cx24108.tunerparms,tunerparms,sizeof(TUNERPARMS));
     
  return(True);

}  /* _TUNER_CX24108_SetParameters() */


/*******************************************************************************************************/
/* _TUNER_CX24108_GetFrequency() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_GetFrequency(    /* returns last frequency set via SetFrequency() to caller */
NIM            *nim,                           /* pointer to nim */
unsigned long  *freq)                          /* pointer to unsigned long where last frequenc will be written */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);
  
  if (freq == NULL)  return(False);

  *freq = nim->frequency;
  return((*freq == 0UL ? False: True));

}  /* _TUNER_CX24108_GetFrequency() */


/*******************************************************************************************************/
/* _TUNER_CX24108_SetFrequency() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_SetFrequency(      /* returns last frequency set via SetFrequency() to caller */
NIM            *nim,                             /* pointer to nim */
unsigned long  freq)                             /* pointer to unsigned long  */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  /* note: nim->freq_ideal hold Fi, used to calculate lnboffset */
  return(_TUNER_CX24108_set_freq(nim,freq));

}  /* _TUNER_CX24108_SetFrequency() */


/*******************************************************************************************************/
/* _TUNER_CX24108_SetLastLock() OBSOLETE */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_SetLastLock(       /* function to set the tuner to the last-known lock (for sw-assisted acq) */
NIM            *nim,                             /* pointer to nim structure */
unsigned long  freq)                             /* pointer to ULONG where last lock is held */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  /* auto-acq is implemented on-chip */
  freq++;
  return(True);

}  /* _TUNER_CX24108_SetLastLock() */


/*******************************************************************************************************/
/* _TUNER_CX24108_GetLastLock() OBSOLETE */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_GetLastLock(       /* function to retrieve last-known lock (for sw-ass'd acq) */
NIM            *nim,                             /* pointer to nim */
unsigned long  *freq)                            /* pointer to ULONG where last-known lock will be written */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  /* auto-acq is implemented on chip */
  if (freq != NULL)  *freq = (*freq)+1UL;
  return(True);

}  /* _TUNER_CX24108_GetLastLock() */


/*******************************************************************************************************/
/* _TUNER_CX24108_GetVCOEdges() */
/*******************************************************************************************************/
BOOL      _TUNER_CX24108_GetVCOEdges(  /* retrieve s VCO edge data, returns copy to caller */
NIM       *nim,                        /* nim pointer */
VCO_EDGE  *vcoedge)                    /* VCO_EDGE struct where VCO edge data will be written */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  if (vcoedge != NULL)
  {
    memcpy(vcoedge,nim->tuner.cx24108.vco_edge,CX24108_VCOEDGE_LEN);
    return(True);
  }

  DRIVER_SetError(nim,API_BAD_PARM);
  return(False);

}  /* _TUNER_CX24108_GetVCOEdges() */


/*******************************************************************************************************/
/* _TUNER_CX24108_SetVCOEdges() */
/*******************************************************************************************************/
BOOL      _TUNER_CX24108_SetVCOEdges(  /* Performs hardware VCO edge detection */
NIM       *nim,                        /* pointer to nim */
VCO_EDGE  *vcoedge)                    /* copy of VCO_edges returned to caller, if vcoedge != NULL */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);
 
  /* if function is passed a NULL, recalc the vco edges */
  if (vcoedge == NULL)
  {
    /* calculate hardware vco edges */
    if (_TUNER_CX24108_hardware_vcoedges(nim) == False)  return(False);
     
    return(True);
  }

  /* copy from nim's tuner buffer into user struct */
  if (vcoedge != NULL && vcoedge != nim->tuner.cx24108.vco_edge)  
    memcpy(vcoedge,nim->tuner.cx24108.vco_edge,CX24108_VCOEDGE_LEN);
  return(True);

}  /* _TUNER_CX24108_SetVCOEdges() */


/*******************************************************************************************************/
/* TUNER_GetVCOBreakpoints() */
/*******************************************************************************************************/
BOOL      _TUNER_CX24108_GetVCOBreakpoints(      /* retrieve s vco breakpoint and vco edge data from NIM */
NIM       *nim,                                  /* pointer to nim */
int       *bp_percentage,                        /* breakpoint percentage returned to caller */
VCO_EDGE  *vcoedge,                              /* vco edge struct returned to caller */
VCO_BP    *vcobp)                                /* vco breakpoint struct returned to caller */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  /* get current bp percentage from vco_bp struct, set last bp% in rosie struct, set user bp% */
  if (bp_percentage != NULL)
  {
    *bp_percentage = (int)nim->tuner.cx24108.vco_bp[0].percentage;
    nim->tuner.cx24108.BPPercentage = (int)nim->tuner.cx24108.vco_bp[0].percentage;
  }
      
  if (vcoedge != NULL)
    memcpy(vcoedge,nim->tuner.cx24108.vco_edge,CX24108_VCOEDGE_LEN);

  if (vcobp != NULL)
    memcpy(vcobp,nim->tuner.cx24108.vco_bp,CX24108_VCOBP_LEN);
  return(True);

}  /* TUNER_CX24108_GetVCOBreakpoints() */


/*******************************************************************************************************/
/* _TUNER_CX24108_SetVCOBreakpointPercentage() */
/*******************************************************************************************************/
BOOL _TUNER_CX24108_SetVCOBreakpointPercentage(  /* sets the breakpoint pcts for the tuner VCO edge calcs */
NIM  *nim,                                       /* pointer to nim */
int  bp_percentage)                              /* breakpoint percentage */
{
  int  i;

  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  /* save the current BP% and set all bp to same */
  nim->tuner.cx24108.BPPercentage = bp_percentage;
  for (i = 0 ; i < CX24108_BPCNT ; i++)
  {
    nim->tuner.cx24108.vco_bp[i].percentage = (unsigned long)nim->tuner.cx24108.BPPercentage;
  }

  /* recalculate edges using new BP % */
  _TUNER_CX24108_calc_bp(nim);

  return(True);
 
}  /* _TUNER_CX24108_SetVCOBreakpointPercentage() */


/*******************************************************************************************************/
/* _TUNER_CX24108_GetVCOBreakpointPercentage() */
/*******************************************************************************************************/
BOOL  _TUNER_CX24108_GetVCOBreakpointPercentage( /* sets the vco breakpoint percentage */
NIM   *nim,                                      /* nim pointer */
int   *bp_percentage)                            /* breakpoint percentage */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  /* pull bp% from current structure, save to current bp setting, return */
  *bp_percentage = (int)nim->tuner.cx24108.vco_bp[0].percentage;
  nim->tuner.cx24108.BPPercentage = *bp_percentage;
  return(True);

}  /* _TUNER_CX24108_GetVCOBreakpointPercentage() */


/*******************************************************************************************************/
/* tunerBWtoV[] */
/*******************************************************************************************************/
static const unsigned int tunerBWtoV[25] = { 
  308U,  402U,  493U,  585U, 
  679U,  780U,  884U,  986U, 
  1084U, 1181U, 1296U, 1400U, 
  1496U, 1596U, 1720U, 1843U, 
  1960U, 2078U, 2209U, 2321U, 
  2436U, 2572U, 2681U, 2867U, 
  3034U};

/*******************************************************************************************************/
/* _TUNER_CX24108_SetFilterBandwidth() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_SetFilterBandwidth(/* function to set the input voltage for tuner's anti-alias filter */
NIM            *nim,                             /* pointer to nim */
unsigned long  bandwidthkhz,                     /* bandwidth in khz */
unsigned long  *mV)                              /* value returned in mV */
{
  unsigned int   fractionalPart;
  unsigned int   index;

  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  /* (CR 6886) */
  nim->antialias_bandwidthkhz = bandwidthkhz;      /* (CR 7482) */
  bandwidthkhz += ANTI_ALIAS_FILTER_UNCERTANTY;
  
  if (bandwidthkhz <= 4000UL)
  {
    *mV = tunerBWtoV[24];
  }
  else if (bandwidthkhz >= 28000UL)
  {
    *mV = 3300UL;
  }
  else
  {
    /* interpolate table */
    fractionalPart = (unsigned int)(bandwidthkhz % 1000UL);
    index = (unsigned int)((bandwidthkhz - 4000UL) / 1000UL);        
        
     *mV = (unsigned long)((fractionalPart * tunerBWtoV[index+1U] + (1000U - fractionalPart) * tunerBWtoV[index]) / 1000U);
     nim->antialias_mV_setting = *mV;
  }

  return(True);

}  /* TUNER_SetFilterBandwidth() */


/*******************************************************************************************************/
/* _TUNER_CX24108_validate() */
/*******************************************************************************************************/
BOOL  _TUNER_CX24108_validate(         /* performs nim and other validation prior to tuner operations */
NIM   *nim)                            /* pointer to nim */
{
  if (nim == NULL)
  {
    DRIVER_SetError(nim,API_NIM_NULL);
    return(False);
  }

  /* validate that the tuner-type is valid */
  if (nim->tuner_type == CX24108)  return(True);

  /* tuner setting not supported */
  DRIVER_SetError(nim,API_NOTSUPPORT);
  return(False);

}  /* _TUNER_CX24108_validate() */


/*******************************************************************************************************/
/* _TUNER_CX24108_validate_rdivval() */
/*******************************************************************************************************/
BOOL     _TUNER_CX24108_validate_rdivval( /* common function to validate r register value */
NIM      *nim,                            /* pointer to nim */
RDIVVAL  rvalue)                          /* r value to test */
{
  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  switch(rvalue)
  {
    case  RDIV_10:
    case  RDIV_20:
    case  RDIV_40:
    {
      break;
    }
    case  RDIV_UNDEF:
    default:
    {
      DRIVER_SetError(nim,API_BAD_PARM);
      return(False);
      break;
    }
  }  /* switch(... */
  return(True);
  
}  /* _TUNER_CX24108_validate_rdivval() */


/*******************************************************************************************************/
/* _TUNER_CX24108_validate_frequency() */
/*******************************************************************************************************/
BOOL          _TUNER_CX24108_validate_frequency( /* common function to validate freq range */
NIM           *nim,                              /* pointer to nim */
unsigned long freq)                              /* freq to range test */
{
  /* test that desired freq is within valid range */
  if (freq < (((unsigned long)FREQ_TUNE_LOW)*MM) || freq > (((unsigned long)FREQ_TUNE_HIGH)*MM))
  {
    DRIVER_SetError(nim,API_PARM_RANGE);
    return(False);
  }
  
  return(True);

}  /* _TUNER_CX24108_validate_frequency() */


/*******************************************************************************************************/
/* _TUNER_CX24108_vco_na() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_vco_na(  /* function to return freq of NA in Khz (this funct is used to calc lsb of a only) */
NIM            *nim,                   /* pointer to nim */
unsigned long  na_str,                 /* NA value (high 9-bits is N reg; low 5 bits is A reg) */ 
unsigned long  *Fvco)                  /* VCO freq returned in hz (subject to runover) */
{
  RDIVVAL  refdiv = nim->tuner.cx24108.R;

  if (_TUNER_CX24108_validate(nim) == False)  return(False);

  if (refdiv != RDIV_10 && refdiv != RDIV_20 && refdiv != RDIV_40)  refdiv = RDIV_10;

  *Fvco = (nim->crystal_freq / refdiv) * (na_str);
  return(True);

}  /* _TUNER_CX24108_vco_na() */


/*******************************************************************************************************/
/* Low-Level Tuner I/O functions */
/*******************************************************************************************************/

/*******************************************************************************************************/
/* _TUNER_CX24108_io() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_io(      /* function that performs i/o to tuner via demod */
NIM            *nim,                   /* nim to send data to */
CX24108_PROG   ctl,                    /* indicates one of: Band Sel, VGA Sel, VCA Sel, or PLL Prog. */
unsigned long  tunerdata)              /* max 19 bits of data to send (this value is range checked) */
{
  int      err = 0;
  
  unsigned long  ulTemp;

  static  unsigned long  tx_to_cx;
  static  unsigned char  out_byte;

  APIERRNO apierr = API_NOERR;

  /* test that control bit settings are legal */
  switch(ctl)
  {
    case  CX24108_BAND_PROG:
    {
      apierr = API_BADCXDATABND;
      break;
    }
    case  CX24108_VGA_PROG:
    {
      apierr = API_BADCXDATAVGA;
      break;
    }
    case  CX24108_VCA_PROG:
    {
      apierr = API_BADCXDATAVCA;
      break;
    }
    case  CX24108_PLL_PROG:
    {
      apierr = API_BADCXDATAPLL;
      break;
    }
    default:
    {
      DRIVER_SetError(nim,API_BAD_CXCTL);
      return(False);
      break;
    }
  }  /* switch(... */

  /* only send the tuner data if it is different from the last programmed
   * tuner data.
   */
  if (nim->tuner.cx24108.ulTunerData_shadow[ctl] == tunerdata)
  {
     return (True);
  }

  /* test tunerdata for valid range */
  if (tunerdata > ((0x01UL<<19UL)-1UL))
  {
    DRIVER_SetError(nim,apierr);
    return(False);
  }

  /* set the ctl bits */
  tx_to_cx = ((unsigned long)ctl<<19UL);

  /* or tunerdata into tx string-like holding vehicle */
  tx_to_cx |= tunerdata;
  tx_to_cx <<= 3UL;

  /* wait for demod to become ready for a new burst sequency */
  _TUNER_WaitForBurstSequenceRdy(nim);

  /* strip 8 x MSb from tx string, send to the tuner */
  ulTemp = ((tx_to_cx & 0xff0000UL)>>16);
  out_byte = (unsigned char)ulTemp;
  if (_TUNER_CX24108_sendbyte(nim,out_byte) != True)  err++;

  ulTemp = ((tx_to_cx & 0xff00UL)>>8);
  out_byte = (unsigned char)ulTemp;
  if (_TUNER_CX24108_sendbyte(nim,out_byte) != True)  err++;

  ulTemp = ((tx_to_cx & 0xf8UL));
  out_byte = (unsigned char)ulTemp;
  if (_TUNER_CX24108_sendbyte(nim,out_byte) != True)  err++;

  /* bring tuner-enable pin high, low once per byte */
  if (_TUNER_CX24108_enable(nim,True) == False)  err++;
  if (_TUNER_CX24108_enable(nim,False) == False)  err++;

  if (err == 0)
  {
     nim->tuner.cx24108.ulTunerData_shadow[ctl] = tunerdata;
     return(True);
  }

  /* unable to perform tuner i/o */
  DRIVER_SetError(nim,API_TUNERERR);
  return(False);

}  /* _TUNER_CX24108_io() */


/*******************************************************************************************************/
/* _TUNER_CX24108_sendbyte() */
/*******************************************************************************************************/
BOOL           _TUNER_CX24108_sendbyte(          /* function to send a byte to the tuner via the demod */
NIM            *nim,                             /* pointer to the nim handle */
unsigned char  out_byte)                         /* BYTE to write to the tuner via the demod */
{
  unsigned long  ulRegVal;

  /* perform byte i/o to tuner */
  if (nim->TUNER_io_method == TUNER_BURST)
  {
    /* demod is ready for byte, so send it!!! */
    ulRegVal = out_byte;
    if (RegisterWrite(nim,CX24130_TUNBURSTDATA,ulRegVal) == False)  
    {
    	return(False);
	}
	/* wait until the byte is sent */
    _TUNER_WaitForBurstByteRdy(nim);
  }
  else
  {
    /* manual bit mode (not supported) */
    return(False);
  }

  return(True);

}  /* _TUNER_CX24108_sendbyte() */


/*******************************************************************************************************/
/* _TUNER_CX24108_defaultsettings() */
/*******************************************************************************************************/
void _TUNER_CX24108_defaultsettings(   /* function to set the tuner i/o settings in the demod to a known default state */
NIM  *nim)                             /* pointer to nim */
{
  unsigned long  ulRegVal;
  int    err = 0;

  /* allow a reset, so next invocation will cause tuner to reset to default */
  if (nim == NULL)  return;

  /* allow the tuner I/O default settings to be set once */
  if (nim->ucTunerIoDefaultSettingsFlag)
  {
      return;
  }
  nim->ucTunerIoDefaultSettingsFlag = True;

  /* set the tuner i/o method once */
  switch(nim->TUNER_io_method)
  {
    case  TUNERIO_UNDEF:
    case  TUNER_BURST:
    {
      /* default to burst */
      nim->TUNER_io_method = TUNER_BURST;

      /* force demod to send in bursts */
      ulRegVal = 0x00;
      if (RegisterWrite(nim,CX24130_TUNBURSTDIS,ulRegVal) == False)  err++;

      /* (CR 8614 - removed) set tuner clock rate to default rate */
      /* ulRegVal = 0x03;  */
      /* if (RegisterWrite(nim,CX24130_TUNBURSTCLKRATE,ulRegVal) == False)  err++;  */

      /* set tuner clock polarity output to default rate */
      ulRegVal = 0x00;
      if (RegisterWrite(nim,CX24130_TUNBURSTCLKPOL,ulRegVal) == False)  err++;

      /* set tuner burst length to default rate */
      ulRegVal = 0x15;
      if (RegisterWrite(nim,CX24130_TUNBURSTLENGTH,ulRegVal) == False)  err++;

      /* find VCO edges at start-up */

      /* report inability to program tuner to default settings (but continue, don't halt) */
      if (err != 0)  DRIVER_SetError(nim,API_TUNERERR);
      break;
    }
    default:
    {
      break;
    }
  }  /* switch(... */
  
  return;

}  /* _TUNER_CX24108_defaultsettings() */


/*******************************************************************************************************/
/* _TUNER_CX24108_enable() */
/*******************************************************************************************************/
BOOL  _TUNER_CX24108_enable(           /* function to write the tuner-enable bit to demod */
NIM   *nim,                            /* pointer to nim handle */
BOOL  opt)                             /* True to force latch high, False to force latch low */
{
  unsigned long  ulRegVal;

  /* strobe the latch enable -- this funct is used by low-level TUNER_xxx_io funct */
  ulRegVal = (opt == True ? 0x01UL : 0x00UL);
  if (RegisterWrite(nim,CX24130_TUNENBIT,ulRegVal) == False)  return(False);
  
  return(True);

}  /* _TUNER_CX24108_enable() */


/*******************************************************************************************************/
/* _TUNER_WaitForBurstSequenceRdy() */
/*******************************************************************************************************/
void _TUNER_WaitForBurstSequenceRdy(  /* func that waits for demod to be ready to send a new burst sequence to tuner */
NIM *nim)                             /* pointer to nim */
{
   unsigned long  ulRegVal;
   unsigned long  ulLoopCnt = (unsigned long)TUNER_BURST_SEQUENCY_WAIT_CYCLES;

   /* wait only when tuner I/O interface is in burst mode */
   if (nim->TUNER_io_method != TUNER_BURST)
   {
      return;
   }

   /* check if demod is ready for a new burst sequence to send to the tuner */
   do
   {
      if (RegisterRead(nim,CX24130_TUNBURSTBUSY,&ulRegVal) == False)
      {
         return;
      }
      if (ulRegVal == 0UL)
      {
         return;
      }
   } while (--ulLoopCnt > 0UL);

   if (ulLoopCnt == 0UL)
   {
      DRIVER_SetError(nim,API_TUNERIO);
   }

   return;
} /* _TUNER_WaitForBurstSequenceRdy() */


/*******************************************************************************************************/
/* _TUNER_WaitForBurstByteRdy() */
/*******************************************************************************************************/
void _TUNER_WaitForBurstByteRdy(  /* func that waits for demod to be ready to send the next burst byte to tuner */
NIM *nim)                         /* pointer to nim */
{
   unsigned long  ulRegVal;
   unsigned long  ulLoopCnt = (unsigned long)TUNER_BURST_BYTE_WAIT_CYCLES;

   /* check if demod is ready for the next burst byte to send to the tuner */
   do
   {
      if (RegisterRead(nim,CX24130_TUNBURSTRDY,&ulRegVal) == False)
      {
         return;
      }
      if (ulRegVal == 1UL)
      {
         return;
      }
   } while (--ulLoopCnt > 0UL);

   if (ulLoopCnt == 0UL)
   {
      DRIVER_SetError(nim,API_TUNERIO);
   }

   return;
} /* _TUNER_WaitForBurstByteRdy() */


/*******************************************************************************************************/
/* _TUNER_CX24108_ready() */
/*******************************************************************************************************/
BOOL  _TUNER_CX24108_ready(            /* function to test if demod is ready for burst to send to tuner */
NIM   *nim)                            /* pointer to nim */ 
{
  unsigned long  ulRegVal;

  /* test if demod is ready for a new burst of bytes to send to the tuner */
  if (RegisterRead(nim,CX24130_TUNBURSTBUSY,&ulRegVal) == False)  return(False);
  if (ulRegVal == 0UL)  return(True);
  
  /* demod is busy sending burst-mode data */
  return(False);

}  /* _TUNER_CX24108_ready() */


/*******************************************************************************************************/
/* _TUNER_CX24108_readybyte() */
/*******************************************************************************************************/
BOOL  _TUNER_CX24108_readybyte(        /* function to test if demod is ready for new byte to send to tuner */
NIM   *nim)                            /* pointer to nim */
{
  unsigned long  ulRegVal;
  
  /* test if demod is ready for the next byte to send to the tuner in burst mode */
  if (RegisterRead(nim,CX24130_TUNBURSTRDY,&ulRegVal) == False)  return(False);
  if (ulRegVal == 0x01UL)  return(True);
  
  /* demod is not ready for the next byte */
  return(False);

}  /* _TUNER_CX24108_readybyte() */


/*******************************************************************************************************/
/* _TUNER_CX24108_io_special() */
/*******************************************************************************************************/
void   _TUNER_CX24108_io_special(      /* Function to perform special performance set-up for CX24108 */
NIM    *nim)                           /* pointer to nim */
{
  int  i;
  int  nim_count = 0;

  NIM  *assd_nim = NULL;   /* associated nim */

  /* special cx24108 considerations:  performance degrades when both NIM channels are programmed */
  /* to the same frequency.  Solution:  force SPECIAL_RANGE offset to 2nd nim (tuned to the same/sim. freq)  */
  
  /* scan through each NIM, looking for 2nd NIM on same chip. */
  for (i = 0 ; i < MAX_NIMS ; i++)
  {
    /* found a candidate ... */
    if (nim_list.nim[i] != NULL)
    {
      nim_count++;

      /* if the nim pointer is different, then we found it (so long as only two nims are present) */
      if (nim_list.nim[i] != nim)
      {
        /* a better method to determine same-chip NIMs must be developed, when multiple chips are used */
        if (nim_count <= 2)
        {
          assd_nim = nim_list.nim[i];

          /* if associated-nim freq is equal to, or associated-nim freq is within 1mhz of desired,   */
          /* adjust the requested freq up or down 1 mhz (if at low edge, adjust up, if at high edge, */
          /* adjust down;  If at neither, then adjust (default) up                                   */
          if (assd_nim->frequency >= (unsigned long)(nim->frequency-(SPECIAL_RANGE*MM))  &&  
            (assd_nim->frequency <= (unsigned long)(nim->frequency+(SPECIAL_RANGE*MM))))
          {
            /* go 1mhz below if near limit of tunable area */
            nim->frequency = (unsigned long)(assd_nim->frequency + (unsigned long)((nim->crystal_freq/RDIV_10)*SPECIAL_RANGE));
            if (nim->frequency > (unsigned long)(2150UL*MM))
              nim->frequency = (unsigned long)(assd_nim->frequency - (unsigned long)((nim->crystal_freq/RDIV_10)*SPECIAL_RANGE));
            return;
          }
        }
      }
    }
  }

  return;

}  /* _TUNER_CX24108_io_special() */


/*******************************************************************************************************/
/*******************************************************************************************************/
/*******************************************************************************************************/
/* CR 9509 : Add an extra newline */

