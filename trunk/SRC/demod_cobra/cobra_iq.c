/* cobra_IQ.c */

/*+++ *******************************************************************\
*
*   Copyright and Disclaimer:
*
*       ---------------------------------------------------------------
*       ALL SOFTWARE, APPLICATIONS, DOCUMENTATION, OR MATERIALS        
*       FURNISHED HEREIN IS PROVIDED *AS IS*.  CONEXANT DOES NOT MAKE  
*       ANY WARRANTIES, EITHER EXPRESS OR IMPLIED, AND HEREBY EXPRESSLY
*       DISCLAIMS ANY AND ALL SUCH WARRANTIES TO THE EXTENT PERMITTED  
*       BY LAW, INCLUDING, SPECIFICALLY, ANY IMPLIED WARRANTY ARISING  
*       BY STATUTE OR OTHERWISE IN LAW OR FROM A COURSE OF DEALING OR  
*       USAGE OF TRADE.  CONEXANT DOES NOT MAKE ANY WARRANTIES, EITHER 
*       EXPRESS OR IMPLIED, AND HEREBY EXPRESSLY DISCLAIMS ANY AND ALL 
*       SUCH WARRANTIES WITH RESPECT TO ALL SOFTWARE, APPLICATIONS,    
*       DOCUMENTATION, AND MATERIALS INCLUDING ALL IMPLIED WARRANTIES  
*       OF MERCHANTABILITY, OR OF MERCHANTABLE QUALITY, OR OF FITNESS  
*       FOR ANY PURPOSE, PARTICULAR, SPECIFIC OR OTHERWISE, OR OF      
*       NONINFRINGEMENT OF INTELLECTUAL PROPERTY RIGHTS OF OTHERS,     
*       RELATING TO THE SOFTWARE, APPLICATIONS, OPERATION,             
*       DOCUMENTATION, DATA OR RESULTS GENERATED BY THE OPERATION OR   
*       USE THEREOF, AND MATERIALS PROVIDED HEREIN.  THE ENTIRE RISK AS
*       TO THE SUBSTANCE, QUALITY AND PERFORMANCE OF SOFTWARE,         
*       APPLICATIONS, AND DOCUMENTATION DESCRIBING SUCH SOFTWARE       
*       REMAINS WITH THE BUYER.                                        
*                                                                      
*       REGARDLESS OF WHETHER ANY REMEDY SET FORTH HEREIN FAILS OF ITS 
*       ESSENTIAL PURPOSE OR OTHERWISE, CONEXANT SHALL NOT BE LIABLE   
*       FOR ANY EXEMPLARY, SPECIAL, PUNITIVE, SPECULATIVE, INDIRECT,   
*       CONSEQUENTIAL OR INCIDENTAL DAMAGES OF ANY KIND (INCLUDING     
*       WITHOUT LIMITATION LOST PROFITS, LOSS OF INCOME, LOSS OF       
*       GOODWILL, OR OTHER TANGIBLE OR INTANGIBLE BUSINESS LOSS)       
*       ARISING OUT OF OR IN CONNECTION WITH, DIRECTLY OR INDIRECTLY,  
*       SOFTWARE, APPLICATIONS, DOCUMENTATION, OR ANY SERVICES OR      
*       MATERIALS PROVIDED HEREUNDER, OR USE OR INABILITY TO USE THE   
*       SOFTWARE, EVEN IF CONEXANT HAS BEEN ADVISED OF THE POSSIBILITY 
*       OF SUCH DAMAGES.                                               
*
*       Copyright (c) 2001 Conexant Systems, Inc.
*       All Rights Reserved.
*       ---------------------------------------------------------------
*
*   Module Revision Id:
*
*       $Header: cobra_iq.c, 6, 3/16/04 11:48:24 AM, Billy Jackman$
*
*   Abstract:
*
*       Contains software for capturing constellation (I and Q values)
*       data into a user-defined ring buffer.
*
\******************************************************************* ---*/

#include <stdio.h>                     /* ANSI Standard */

#include "cobra.h"                     /* Cobra include files, ordered */

#ifdef INCLUDE_CONSTELLATION
/*******************************************************************************************************/
/* API_ConstON() */
/*******************************************************************************************************/
BOOL  API_ConstOn(                     /* function to turn-on the collection oc constellation data */
NIM    *nim,                           /* pointer to nim */
IQPAK  *iqpak)                         /* pointer to storage for IQPAK data */
{
  int  i = 0;

  /* test for valid NIM */
  if (DRIVER_ValidateNim(nim) == False)  return(False);

  /* test for valid iqpak */
  nim->iqpak = iqpak;
  if (DRIVER_ValidateNimIq(nim) == False)  return(False);

  /* clear the struct of data */
  for (i = 0 ; i < MAX_CONSTLIQ ; i++)
  {
    iqpak->I[i] = 0;
    iqpak->Q[i] = 0;
  }

  /* save the pointer to the alloc'd storage */
  nim->iqpak = iqpak;

  /* set the head/tail */
  iqpak->head = 0;
  iqpak->tail = 0;

  /* save the number of samples desired, clear the busy flag */
  iqpak->max = MAX_CONSTLIQ;
  iqpak->busy = False;

  return(True);

}  /* API_ConstON() */


/*******************************************************************************************************/
/* API_ConstOFF() */
/*******************************************************************************************************/
BOOL  API_ConstOff(                    /* function to discontinue collection of IQ data */
NIM   *nim)                            /* pointer to nim */
{
  /* test for valid IQ pointer */
  if (DRIVER_ValidateNimIq(nim) == False)  return(False);

  nim->iqpak->head = 0;
  nim->iqpak->tail = 0;

  /* kill the pointer in the nim */
  nim->iqpak = NULL;
  
  return(True);

}  /* API_ConstOFF() */


/*******************************************************************************************************/
/* API_ConstOFF() */
/*******************************************************************************************************/
int  API_ConstCount(                   /* function returning count of IQ elements stored in IQPAK */
NIM   *nim)                            /* pointer to nim */
{
  /* test for valid NIM, IQ pointer */
  if (DRIVER_ValidateNim(nim) == False)  return(False);
  if (DRIVER_ValidateNimIq(nim) == False)  return(False);

  return(IQ_ConstCount(nim));

}  /* API_ConstOFF() */


/*******************************************************************************************************/
/* API_ConstSetBusy() */
/*******************************************************************************************************/
BOOL  API_ConstSetBusy(                /* function set IQ busy flag (if set, suspend IQ collection) */
NIM    *nim,                           /* pointer to nim */
BOOL   busy_state)                     /* state: True=busy, False=not busy */
{
  /* test for valid IQ pointer */
  if (DRIVER_ValidateNimIq(nim) == False)  return(False);

  /* set busy state */
  nim->iqpak->busy = busy_state;
  return(True);

}  /* API_ConstSetBusy() */


/*******************************************************************************************************/
/* API_ConstGetBusy() */
/*******************************************************************************************************/
BOOL  API_ConstGetBusy(                /* function to return state of current IQ busy flag */
NIM    *nim)                           /* pointer to nim */
{
  /* test for valid IQ pointer */
  if (DRIVER_ValidateNimIq(nim) == False)  return(False);

  /* return busy state */
  return(nim->iqpak->busy);

}  /* API_ConstGetBusy() */


/*******************************************************************************************************/
/* API_ConstGetPoints() */
/*******************************************************************************************************/
BOOL           API_ConstGetPoints(     /* function to return a iqcount of IQ samples */
NIM            *nim,                   /* pointer to nim */
unsigned char  *ivals,                 /* storage for I portion of data */
unsigned char  *qvals,                 /* storage for Q portion of data */
int            iqcount)                /* count of IQ samples to retrieve  */
{
  int  cnt;
  int  ptr;

  /* test for valid IQ pointer */
  if (DRIVER_ValidateNimIq(nim) == False)  return(False);

  /* test for valid buffers */
  if (ivals == NULL || qvals == NULL)  
  {
    /* invalid pointer */
    DRIVER_SetError(nim,API_CONST_IQBUF);
    return(False);
  }

  /* test for minimum count of I, Q samples available to caller */
  if (iqcount > IQ_ConstCount(nim))
  {
    DRIVER_SetError(nim,API_CONST_IQLOW);
    return(False);
  }
  
  /* copy data from IQPAK to user buffer */
  for (cnt = 0 ; cnt < iqcount ; cnt++)
  {
    ptr = (nim->iqpak->head+cnt)%nim->iqpak->max;
    ivals[cnt] = nim->iqpak->I[ptr];
    qvals[cnt] = nim->iqpak->Q[ptr];
  }

  return(True);

}  /* API_ConstGetPoints() */


/*******************************************************************************************************/
/* API_ConstGetIQSample() */
/*******************************************************************************************************/
BOOL           API_ConstGetIQSample(   /* function to retrieve  IQ sample from hardware */
NIM            *nim,                   /* pointer to nim */
unsigned char  *I,                     /* pointer to where I portion will be written */
unsigned char  *Q)                     /* pointer to where Q portion will be written */
{
  /* proposed API to retrieve  data from IQ_SampleGetIq() */

  /* test for valid IQ pointer */
  if (DRIVER_ValidateNimIq(nim) == False)  return(False);

  /* test for valid buffers */
  if (I == NULL || Q == NULL)  
  {
    /* invalid pointer */
    DRIVER_SetError(nim,API_CONST_IQBUF);
    return(False);
  }

  /* retrieve I, Q samples directly from hardware via ser.bus */
  return (IQ_SampleGetIq(nim,I,Q));

}  /* API_ConstGetIQSample() */

 
/*******************************************************************************************************/
/* IQ_SampleGetIq() */
/*******************************************************************************************************/
BOOL           IQ_SampleGetIq(         /* function to retrieve  I,Q sample data from hardware */
NIM            *nim,                   /* pointer to nim */
unsigned char  *ival,                  /* pointer to storage for I */
unsigned char  *qval)                  /* pointer to storage for Q */
{
  unsigned char   temp1;
  unsigned char   temp2;

  unsigned long  ulRegVal;
  int    err = 0;

  /* read the IQ register twice -- first s/b I or Q, 2nd s/b Q or I */
  if (RegisterRead(nim,CX24130_CONSTIQ,&ulRegVal) != True)  err++;
  temp1 = (unsigned char)ulRegVal;
  if (RegisterRead(nim,CX24130_CONSTIQ,&ulRegVal) != True)  err++;
  temp2 = (unsigned char)ulRegVal;

  /* test that the bytes were read */
  if (err == 0)
  {
    /* test that I, Q data are paired.  If not, save 2nd read, try to get the next match */
    if ((temp1&0x80) != (temp2&0x80))
    {
      /* pairs did not match, so more temp2 to temp1, then try to read again */
      temp1 = temp2;
      if (RegisterRead(nim,CX24130_CONSTIQ,&ulRegVal) != True)  err++;
      temp1 = (unsigned char)ulRegVal;

      /* if bytes are NOT matched, then we got a hardware prob.  report prob */
      if ((temp1&0x80) != (temp2&0x80))
      {
        /* unable to match I, Q pair.  report error */
        DRIVER_SetError(nim,API_IQ_IO);
        return(False);
      }
    }

    /* pairs did match, place them in order, return values to caller */
    if ((temp1&0x40) == 0x40)
    {
      *qval = (unsigned char)(temp1&0x3f);
      *ival = (unsigned char)(temp2&0x3f);
    }
    else
    {
      *ival = (unsigned char)(temp1&0x3f);
      *qval = (unsigned char)(temp2&0x3f);
    }
    return(True);
  }

  DRIVER_SetError(nim,API_IQ_IO);
  return(False);
  
}  /* IQ_SampleGetIq() */


/*******************************************************************************************************/
/* IQ_Sample() */
/*******************************************************************************************************/
BOOL  IQ_Sample(                       /* function to retrieve I,Q data from demod, place into IQPAK */
NIM   *nim)                            /* pointer to nim */
{
  static unsigned char  I = 0;     /* static for testing only */
  static unsigned char  Q = 0;

  /* test for valid NIM, IQ pointer */
  if (DRIVER_ValidateNim(nim) == False)  return(False);
  if (DRIVER_ValidateNimIq(nim) == False)  return(False);

  /* test for IQ busy -- don't save I,Q data if busy -- if busy, return TRUE (no error, just busy!) */
  if (nim->iqpak->busy == True)  return(True);
  
  /* extract the I, Q values from the Demod */
  if (IQ_SampleGetIq(nim,&I,&Q) == False)  return(False);

  /* determine where to place I,Q data */
  nim->iqpak->tail++;
  if (nim->iqpak->tail == nim->iqpak->head)  
  {
    nim->iqpak->head++;
    if (nim->iqpak->head >= nim->iqpak->max)  nim->iqpak->head = 0;
   
  }
  if (nim->iqpak->tail >= nim->iqpak->max)
  {
    /* tail has wrapped around */
    nim->iqpak->tail = 0;
    nim->iqpak->head++;
    if (nim->iqpak->head >= nim->iqpak->max)
    {
      nim->iqpak->head = 0;
    }
  }
  
  /* place the I,Q values into the buffer */
  nim->iqpak->I[nim->iqpak->tail] = I;
  nim->iqpak->Q[nim->iqpak->tail] = Q;
    
  return(True);

}  /* IQ_Sample() */


/*******************************************************************************************************/
/* IQ_ConstCount() */
/*******************************************************************************************************/
int  IQ_ConstCount(                    /* function to return the count of IQ samples in IQPAK */
NIM   *nim)                            /* pointer to nim */
{
  /* return count of I,Q values saved */
  return( (nim->iqpak->head>nim->iqpak->tail?nim->iqpak->max-(nim->iqpak->head-nim->iqpak->tail-1)
        :nim->iqpak->tail-nim->iqpak->head) );
}  /* IQ_ConstCount() */


/*******************************************************************************************************/
/* API_ConstGetUnbufferedIQSample() */
/*******************************************************************************************************/
BOOL         API_ConstGetUnbufferedIQSample(  /* funct to return unbuffered i, q results from demod */
NIM          *nim,                            /* pointer to nim */
signed char  *I,                              /* pointer to storage where I value will be returned to caller */
signed char  *Q)                              /* pointer to storage where Q value will be returned to caller */
{
  unsigned char  i;
  unsigned char  q;

  /* grab raw I,Q data from demod, convert it into a pos/neg */
  if (IQ_SampleGetIq(nim,&i,&q) == False)  return(False);

  *I = (signed char)DRIVER_convert_twos(i,6);
  *Q = (signed char)DRIVER_convert_twos(q,6);

  return(True);

}  /* API_ConstGetUnbufferedIQSample() */

/*******************************************************************************************************/
/*******************************************************************************************************/

#else
int __cobra_iq_dummy;
#endif  /* #ifdef INCLUDE_CONSTELLATION */


/*******************************************************************************************************/
/*******************************************************************************************************/
/*******************************************************************************************************/
/* CR 9509 : Add an extra newline */

